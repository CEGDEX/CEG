// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: overlay.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Overlay.pbobjc.h"
 #import "Common.pbobjc.h"
 #import "Chain.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - OverlayRoot

@implementation OverlayRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - OverlayRoot_FileDescriptor

static GPBFileDescriptor *OverlayRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum OVERLAY_MESSAGE_TYPE

GPBEnumDescriptor *OVERLAY_MESSAGE_TYPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "OverlayMsgtypeNone\000OverlayMsgtypePing\000Ov"
        "erlayMsgtypeHello\000OverlayMsgtypePeers\000Ov"
        "erlayMsgtypeTransaction\000OverlayMsgtypeLe"
        "dgers\000OverlayMsgtypePbft\000OverlayMsgtypeL"
        "edgerUpgradeNotify\000";
    static const int32_t values[] = {
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypeNone,
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypePing,
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypeHello,
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypePeers,
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypeTransaction,
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypeLedgers,
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypePbft,
        OVERLAY_MESSAGE_TYPE_OverlayMsgtypeLedgerUpgradeNotify,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OVERLAY_MESSAGE_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OVERLAY_MESSAGE_TYPE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OVERLAY_MESSAGE_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypeNone:
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypePing:
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypeHello:
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypePeers:
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypeTransaction:
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypeLedgers:
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypePbft:
    case OVERLAY_MESSAGE_TYPE_OverlayMsgtypeLedgerUpgradeNotify:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChainMessageType

GPBEnumDescriptor *ChainMessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ChainTypeNone\000ChainHello\000ChainTxStatus\000C"
        "hainPeerOnline\000ChainPeerOffline\000ChainPee"
        "rMessage\000ChainSubmittransaction\000ChainLed"
        "gerHeader\000ChainSubscribeTx\000ChainTxEnvSto"
        "re\000";
    static const int32_t values[] = {
        ChainMessageType_ChainTypeNone,
        ChainMessageType_ChainHello,
        ChainMessageType_ChainTxStatus,
        ChainMessageType_ChainPeerOnline,
        ChainMessageType_ChainPeerOffline,
        ChainMessageType_ChainPeerMessage,
        ChainMessageType_ChainSubmittransaction,
        ChainMessageType_ChainLedgerHeader,
        ChainMessageType_ChainSubscribeTx,
        ChainMessageType_ChainTxEnvStore,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChainMessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChainMessageType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChainMessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChainMessageType_ChainTypeNone:
    case ChainMessageType_ChainHello:
    case ChainMessageType_ChainTxStatus:
    case ChainMessageType_ChainPeerOnline:
    case ChainMessageType_ChainPeerOffline:
    case ChainMessageType_ChainPeerMessage:
    case ChainMessageType_ChainSubmittransaction:
    case ChainMessageType_ChainLedgerHeader:
    case ChainMessageType_ChainSubscribeTx:
    case ChainMessageType_ChainTxEnvStore:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Hello

@implementation Hello

@dynamic networkId;
@dynamic ledgerVersion;
@dynamic overlayVersion;
@dynamic CEGVersion;
@dynamic listeningPort;
@dynamic nodeAddress;
@dynamic nodeRand;

typedef struct Hello__storage_ {
  uint32_t _has_storage_[1];
  NSString *CEGVersion;
  NSString *nodeAddress;
  NSString *nodeRand;
  int64_t networkId;
  int64_t ledgerVersion;
  int64_t overlayVersion;
  int64_t listeningPort;
} Hello__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "networkId",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_NetworkId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Hello__storage_, networkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ledgerVersion",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_LedgerVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Hello__storage_, ledgerVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "overlayVersion",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_OverlayVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Hello__storage_, overlayVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "CEGVersion",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_CEGVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Hello__storage_, CEGVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listeningPort",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_ListeningPort,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Hello__storage_, listeningPort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nodeAddress",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_NodeAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Hello__storage_, nodeAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nodeRand",
        .dataTypeSpecific.className = NULL,
        .number = Hello_FieldNumber_NodeRand,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Hello__storage_, nodeRand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Hello class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Hello__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HelloResponse

@implementation HelloResponse

@dynamic errorCode;
@dynamic errorDesc;

typedef struct HelloResponse__storage_ {
  uint32_t _has_storage_[1];
  ERRORCODE errorCode;
  NSString *errorDesc;
} HelloResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = ERRORCODE_EnumDescriptor,
        .number = HelloResponse_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloResponse__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "errorDesc",
        .dataTypeSpecific.className = NULL,
        .number = HelloResponse_FieldNumber_ErrorDesc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloResponse__storage_, errorDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloResponse class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t HelloResponse_ErrorCode_RawValue(HelloResponse *message) {
  GPBDescriptor *descriptor = [HelloResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HelloResponse_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetHelloResponse_ErrorCode_RawValue(HelloResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [HelloResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HelloResponse_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Peer

@implementation Peer

@dynamic ip;
@dynamic port;
@dynamic numFailures;
@dynamic nextAttemptTime;
@dynamic activeTime;
@dynamic connectionId;

typedef struct Peer__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
  int64_t port;
  int64_t numFailures;
  int64_t nextAttemptTime;
  int64_t activeTime;
  int64_t connectionId;
} Peer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Peer__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Peer__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numFailures",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_NumFailures,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Peer__storage_, numFailures),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nextAttemptTime",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_NextAttemptTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Peer__storage_, nextAttemptTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "activeTime",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_ActiveTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Peer__storage_, activeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "connectionId",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_ConnectionId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Peer__storage_, connectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peer class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Peers

@implementation Peers

@dynamic peersArray, peersArray_Count;

typedef struct Peers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} Peers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = Peers_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Peers__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peers class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLedgers

@implementation GetLedgers

@dynamic begin;
@dynamic end;
@dynamic timestamp;

typedef struct GetLedgers__storage_ {
  uint32_t _has_storage_[1];
  int64_t begin;
  int64_t end;
  int64_t timestamp;
} GetLedgers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "begin",
        .dataTypeSpecific.className = NULL,
        .number = GetLedgers_FieldNumber_Begin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLedgers__storage_, begin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GetLedgers_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLedgers__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = GetLedgers_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLedgers__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLedgers class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLedgers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ledgers

@implementation Ledgers

@dynamic valuesArray, valuesArray_Count;
@dynamic syncCode;
@dynamic maxSeq;
@dynamic proof;

typedef struct Ledgers__storage_ {
  uint32_t _has_storage_[1];
  Ledgers_SyncCode syncCode;
  NSMutableArray *valuesArray;
  NSData *proof;
  int64_t maxSeq;
} Ledgers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ConsensusValue),
        .number = Ledgers_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Ledgers__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncCode",
        .dataTypeSpecific.enumDescFunc = Ledgers_SyncCode_EnumDescriptor,
        .number = Ledgers_FieldNumber_SyncCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Ledgers__storage_, syncCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "maxSeq",
        .dataTypeSpecific.className = NULL,
        .number = Ledgers_FieldNumber_MaxSeq,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Ledgers__storage_, maxSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "proof",
        .dataTypeSpecific.className = NULL,
        .number = Ledgers_FieldNumber_Proof,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Ledgers__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Ledgers class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ledgers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Ledgers_SyncCode_RawValue(Ledgers *message) {
  GPBDescriptor *descriptor = [Ledgers descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Ledgers_FieldNumber_SyncCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetLedgers_SyncCode_RawValue(Ledgers *message, int32_t value) {
  GPBDescriptor *descriptor = [Ledgers descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Ledgers_FieldNumber_SyncCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Ledgers_SyncCode

GPBEnumDescriptor *Ledgers_SyncCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000OutOfSync\000OutOfLedgers\000Busy\000Refuse\000In"
        "ternal\000";
    static const int32_t values[] = {
        Ledgers_SyncCode_Ok,
        Ledgers_SyncCode_OutOfSync,
        Ledgers_SyncCode_OutOfLedgers,
        Ledgers_SyncCode_Busy,
        Ledgers_SyncCode_Refuse,
        Ledgers_SyncCode_Internal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Ledgers_SyncCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Ledgers_SyncCode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Ledgers_SyncCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case Ledgers_SyncCode_Ok:
    case Ledgers_SyncCode_OutOfSync:
    case Ledgers_SyncCode_OutOfLedgers:
    case Ledgers_SyncCode_Busy:
    case Ledgers_SyncCode_Refuse:
    case Ledgers_SyncCode_Internal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DontHave

@implementation DontHave

@dynamic type;
@dynamic hash_p;

typedef struct DontHave__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t type;
} DontHave__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = DontHave_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DontHave__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = DontHave_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DontHave__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DontHave class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DontHave__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LedgerUpgradeNotify

@implementation LedgerUpgradeNotify

@dynamic nonce;
@dynamic hasUpgrade, upgrade;
@dynamic hasSignature, signature;

typedef struct LedgerUpgradeNotify__storage_ {
  uint32_t _has_storage_[1];
  LedgerUpgrade *upgrade;
  Signature *signature;
  int64_t nonce;
} LedgerUpgradeNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = LedgerUpgradeNotify_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LedgerUpgradeNotify__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "upgrade",
        .dataTypeSpecific.className = GPBStringifySymbol(LedgerUpgrade),
        .number = LedgerUpgradeNotify_FieldNumber_Upgrade,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LedgerUpgradeNotify__storage_, upgrade),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = LedgerUpgradeNotify_FieldNumber_Signature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LedgerUpgradeNotify__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LedgerUpgradeNotify class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LedgerUpgradeNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EntryList

@implementation EntryList

@dynamic entryArray, entryArray_Count;

typedef struct EntryList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entryArray;
} EntryList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entryArray",
        .dataTypeSpecific.className = NULL,
        .number = EntryList_FieldNumber_EntryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EntryList__storage_, entryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EntryList class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EntryList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainHello

@implementation ChainHello

@dynamic apiListArray, apiListArray_Count;
@dynamic timestamp;

typedef struct ChainHello__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *apiListArray;
  int64_t timestamp;
} ChainHello__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "apiListArray",
        .dataTypeSpecific.enumDescFunc = ChainMessageType_EnumDescriptor,
        .number = ChainHello_FieldNumber_ApiListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainHello__storage_, apiListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ChainHello_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainHello__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainHello class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainHello__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainStatus

@implementation ChainStatus

@dynamic selfAddr;
@dynamic ledgerVersion;
@dynamic monitorVersion;
@dynamic CEGVersion;
@dynamic timestamp;

typedef struct ChainStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *selfAddr;
  NSString *CEGVersion;
  int64_t ledgerVersion;
  int64_t monitorVersion;
  int64_t timestamp;
} ChainStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "selfAddr",
        .dataTypeSpecific.className = NULL,
        .number = ChainStatus_FieldNumber_SelfAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainStatus__storage_, selfAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ledgerVersion",
        .dataTypeSpecific.className = NULL,
        .number = ChainStatus_FieldNumber_LedgerVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainStatus__storage_, ledgerVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "monitorVersion",
        .dataTypeSpecific.className = NULL,
        .number = ChainStatus_FieldNumber_MonitorVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChainStatus__storage_, monitorVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "CEGVersion",
        .dataTypeSpecific.className = NULL,
        .number = ChainStatus_FieldNumber_CEGVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChainStatus__storage_, CEGVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ChainStatus_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChainStatus__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainStatus class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainPeerMessage

@implementation ChainPeerMessage

@dynamic srcPeerAddr;
@dynamic desPeerAddrsArray, desPeerAddrsArray_Count;
@dynamic data_p;

typedef struct ChainPeerMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *srcPeerAddr;
  NSMutableArray *desPeerAddrsArray;
  NSData *data_p;
} ChainPeerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "srcPeerAddr",
        .dataTypeSpecific.className = NULL,
        .number = ChainPeerMessage_FieldNumber_SrcPeerAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainPeerMessage__storage_, srcPeerAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desPeerAddrsArray",
        .dataTypeSpecific.className = NULL,
        .number = ChainPeerMessage_FieldNumber_DesPeerAddrsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainPeerMessage__storage_, desPeerAddrsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = ChainPeerMessage_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainPeerMessage__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainPeerMessage class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainPeerMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainSubscribeTx

@implementation ChainSubscribeTx

@dynamic addressArray, addressArray_Count;

typedef struct ChainSubscribeTx__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressArray;
} ChainSubscribeTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressArray",
        .dataTypeSpecific.className = NULL,
        .number = ChainSubscribeTx_FieldNumber_AddressArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainSubscribeTx__storage_, addressArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainSubscribeTx class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainSubscribeTx__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainResponse

@implementation ChainResponse

@dynamic errorCode;
@dynamic errorDesc;

typedef struct ChainResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorDesc;
} ChainResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = ChainResponse_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainResponse__storage_, errorCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errorDesc",
        .dataTypeSpecific.className = NULL,
        .number = ChainResponse_FieldNumber_ErrorDesc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainResponse__storage_, errorDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainResponse class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainTxStatus

@implementation ChainTxStatus

@dynamic status;
@dynamic txHash;
@dynamic sourceAddress;
@dynamic sourceAccountSeq;
@dynamic ledgerSeq;
@dynamic newAccountSeq;
@dynamic errorCode;
@dynamic errorDesc;
@dynamic timestamp;

typedef struct ChainTxStatus__storage_ {
  uint32_t _has_storage_[1];
  ChainTxStatus_TxStatus status;
  ERRORCODE errorCode;
  NSString *txHash;
  NSString *sourceAddress;
  NSString *errorDesc;
  int64_t sourceAccountSeq;
  int64_t ledgerSeq;
  int64_t newAccountSeq;
  int64_t timestamp;
} ChainTxStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ChainTxStatus_TxStatus_EnumDescriptor,
        .number = ChainTxStatus_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = ChainTxStatus_FieldNumber_TxHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceAddress",
        .dataTypeSpecific.className = NULL,
        .number = ChainTxStatus_FieldNumber_SourceAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, sourceAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceAccountSeq",
        .dataTypeSpecific.className = NULL,
        .number = ChainTxStatus_FieldNumber_SourceAccountSeq,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, sourceAccountSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ledgerSeq",
        .dataTypeSpecific.className = NULL,
        .number = ChainTxStatus_FieldNumber_LedgerSeq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, ledgerSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "newAccountSeq",
        .dataTypeSpecific.className = NULL,
        .number = ChainTxStatus_FieldNumber_NewAccountSeq,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, newAccountSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = ERRORCODE_EnumDescriptor,
        .number = ChainTxStatus_FieldNumber_ErrorCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "errorDesc",
        .dataTypeSpecific.className = NULL,
        .number = ChainTxStatus_FieldNumber_ErrorDesc,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, errorDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ChainTxStatus_FieldNumber_Timestamp,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ChainTxStatus__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainTxStatus class]
                                     rootClass:[OverlayRoot class]
                                          file:OverlayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainTxStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChainTxStatus_Status_RawValue(ChainTxStatus *message) {
  GPBDescriptor *descriptor = [ChainTxStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChainTxStatus_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetChainTxStatus_Status_RawValue(ChainTxStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [ChainTxStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChainTxStatus_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ChainTxStatus_ErrorCode_RawValue(ChainTxStatus *message) {
  GPBDescriptor *descriptor = [ChainTxStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChainTxStatus_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetChainTxStatus_ErrorCode_RawValue(ChainTxStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [ChainTxStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChainTxStatus_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ChainTxStatus_TxStatus

GPBEnumDescriptor *ChainTxStatus_TxStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Undefined\000Confirmed\000Pending\000Complete\000Fai"
        "lure\000";
    static const int32_t values[] = {
        ChainTxStatus_TxStatus_Undefined,
        ChainTxStatus_TxStatus_Confirmed,
        ChainTxStatus_TxStatus_Pending,
        ChainTxStatus_TxStatus_Complete,
        ChainTxStatus_TxStatus_Failure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChainTxStatus_TxStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChainTxStatus_TxStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChainTxStatus_TxStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChainTxStatus_TxStatus_Undefined:
    case ChainTxStatus_TxStatus_Confirmed:
    case ChainTxStatus_TxStatus_Pending:
    case ChainTxStatus_TxStatus_Complete:
    case ChainTxStatus_TxStatus_Failure:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
