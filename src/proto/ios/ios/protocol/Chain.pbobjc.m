// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chain.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Chain.pbobjc.h"
 #import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ChainRoot

@implementation ChainRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ChainRoot_FileDescriptor

static GPBFileDescriptor *ChainRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Limit

GPBEnumDescriptor *Limit_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Signature\000";
    static const int32_t values[] = {
        Limit_Unknown,
        Limit_Signature,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Limit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Limit_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Limit_IsValidValue(int32_t value__) {
  switch (value__) {
    case Limit_Unknown:
    case Limit_Signature:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Account

@implementation Account

@dynamic address;
@dynamic nonce;
@dynamic hasPriv, priv;
@dynamic metadatasHash;
@dynamic assetsHash;
@dynamic hasContract, contract;
@dynamic balance;

typedef struct Account__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  AccountPrivilege *priv;
  NSData *metadatasHash;
  NSData *assetsHash;
  Contract *contract;
  int64_t nonce;
  int64_t balance;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Nonce,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "priv",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountPrivilege),
        .number = Account_FieldNumber_Priv,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account__storage_, priv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadatasHash",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_MetadatasHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account__storage_, metadatasHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetsHash",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AssetsHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Account__storage_, assetsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contract",
        .dataTypeSpecific.className = GPBStringifySymbol(Contract),
        .number = Account_FieldNumber_Contract,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Account__storage_, contract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Balance,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Account__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssetKey

@implementation AssetKey

@dynamic issuer;
@dynamic code;
@dynamic type;

typedef struct AssetKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *issuer;
  NSString *code;
} AssetKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "issuer",
        .dataTypeSpecific.className = NULL,
        .number = AssetKey_FieldNumber_Issuer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetKey__storage_, issuer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AssetKey_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AssetKey__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AssetKey_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AssetKey__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetKey class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Asset

@implementation Asset

@dynamic hasKey, key;
@dynamic amount;

typedef struct Asset__storage_ {
  uint32_t _has_storage_[1];
  AssetKey *key;
  int64_t amount;
} Asset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(AssetKey),
        .number = Asset_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Asset__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Asset_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Asset__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Asset class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Asset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssetProperty

@implementation AssetProperty

@dynamic decimal;
@dynamic description_p;
@dynamic maxSupply;
@dynamic issuedAmount;
@dynamic feePercent;

typedef struct AssetProperty__storage_ {
  uint32_t _has_storage_[1];
  int32_t decimal;
  int32_t feePercent;
  NSString *description_p;
  int64_t maxSupply;
  int64_t issuedAmount;
} AssetProperty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "decimal",
        .dataTypeSpecific.className = NULL,
        .number = AssetProperty_FieldNumber_Decimal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetProperty__storage_, decimal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = AssetProperty_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AssetProperty__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxSupply",
        .dataTypeSpecific.className = NULL,
        .number = AssetProperty_FieldNumber_MaxSupply,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AssetProperty__storage_, maxSupply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "issuedAmount",
        .dataTypeSpecific.className = NULL,
        .number = AssetProperty_FieldNumber_IssuedAmount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AssetProperty__storage_, issuedAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePercent",
        .dataTypeSpecific.className = NULL,
        .number = AssetProperty_FieldNumber_FeePercent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AssetProperty__storage_, feePercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetProperty class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetProperty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssetStore

@implementation AssetStore

@dynamic hasKey, key;
@dynamic amount;
@dynamic hasProperty, property;

typedef struct AssetStore__storage_ {
  uint32_t _has_storage_[1];
  AssetKey *key;
  AssetProperty *property;
  int64_t amount;
} AssetStore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(AssetKey),
        .number = AssetStore_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetStore__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = AssetStore_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AssetStore__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "property",
        .dataTypeSpecific.className = GPBStringifySymbol(AssetProperty),
        .number = AssetStore_FieldNumber_Property,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AssetStore__storage_, property),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetStore class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetStore__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LedgerHeader

@implementation LedgerHeader

@dynamic seq;
@dynamic hash_p;
@dynamic previousHash;
@dynamic accountTreeHash;
@dynamic closeTime;
@dynamic consensusValueHash;
@dynamic version;
@dynamic txCount;
@dynamic validatorsHash;
@dynamic feesHash;
@dynamic reserve;

typedef struct LedgerHeader__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  NSData *previousHash;
  NSData *accountTreeHash;
  NSData *consensusValueHash;
  NSData *validatorsHash;
  NSData *feesHash;
  NSString *reserve;
  int64_t seq;
  int64_t closeTime;
  int64_t version;
  int64_t txCount;
} LedgerHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seq",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_Seq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, seq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "previousHash",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_PreviousHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, previousHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accountTreeHash",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_AccountTreeHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, accountTreeHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "closeTime",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_CloseTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, closeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "consensusValueHash",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_ConsensusValueHash,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, consensusValueHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_Version,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txCount",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_TxCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, txCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "validatorsHash",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_ValidatorsHash,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, validatorsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "feesHash",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_FeesHash,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, feesHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "reserve",
        .dataTypeSpecific.className = NULL,
        .number = LedgerHeader_FieldNumber_Reserve,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LedgerHeader__storage_, reserve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LedgerHeader class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LedgerHeader__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ledger

@implementation Ledger

@dynamic hasHeader, header;
@dynamic transactionEnvsArray, transactionEnvsArray_Count;

typedef struct Ledger__storage_ {
  uint32_t _has_storage_[1];
  LedgerHeader *header;
  NSMutableArray *transactionEnvsArray;
} Ledger__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(LedgerHeader),
        .number = Ledger_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Ledger__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionEnvsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionEnv),
        .number = Ledger_FieldNumber_TransactionEnvsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Ledger__storage_, transactionEnvsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Ledger class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ledger__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationPayAsset

@implementation OperationPayAsset

@dynamic destAddress;
@dynamic hasAsset, asset;
@dynamic input;

typedef struct OperationPayAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *destAddress;
  Asset *asset;
  NSString *input;
} OperationPayAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "destAddress",
        .dataTypeSpecific.className = NULL,
        .number = OperationPayAsset_FieldNumber_DestAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationPayAsset__storage_, destAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "asset",
        .dataTypeSpecific.className = GPBStringifySymbol(Asset),
        .number = OperationPayAsset_FieldNumber_Asset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperationPayAsset__storage_, asset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "input",
        .dataTypeSpecific.className = NULL,
        .number = OperationPayAsset_FieldNumber_Input,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OperationPayAsset__storage_, input),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationPayAsset class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationPayAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationTypeThreshold

@implementation OperationTypeThreshold

@dynamic type;
@dynamic threshold;

typedef struct OperationTypeThreshold__storage_ {
  uint32_t _has_storage_[1];
  Operation_Type type;
  int64_t threshold;
} OperationTypeThreshold__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Operation_Type_EnumDescriptor,
        .number = OperationTypeThreshold_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationTypeThreshold__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = OperationTypeThreshold_FieldNumber_Threshold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperationTypeThreshold__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationTypeThreshold class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationTypeThreshold__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OperationTypeThreshold_Type_RawValue(OperationTypeThreshold *message) {
  GPBDescriptor *descriptor = [OperationTypeThreshold descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OperationTypeThreshold_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetOperationTypeThreshold_Type_RawValue(OperationTypeThreshold *message, int32_t value) {
  GPBDescriptor *descriptor = [OperationTypeThreshold descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OperationTypeThreshold_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AccountPrivilege

@implementation AccountPrivilege

@dynamic masterWeight;
@dynamic signersArray, signersArray_Count;
@dynamic hasThresholds, thresholds;

typedef struct AccountPrivilege__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *signersArray;
  AccountThreshold *thresholds;
  int64_t masterWeight;
} AccountPrivilege__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterWeight",
        .dataTypeSpecific.className = NULL,
        .number = AccountPrivilege_FieldNumber_MasterWeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountPrivilege__storage_, masterWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "signersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signer),
        .number = AccountPrivilege_FieldNumber_SignersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountPrivilege__storage_, signersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "thresholds",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountThreshold),
        .number = AccountPrivilege_FieldNumber_Thresholds,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountPrivilege__storage_, thresholds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountPrivilege class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountPrivilege__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountThreshold

@implementation AccountThreshold

@dynamic txThreshold;
@dynamic typeThresholdsArray, typeThresholdsArray_Count;

typedef struct AccountThreshold__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *typeThresholdsArray;
  int64_t txThreshold;
} AccountThreshold__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txThreshold",
        .dataTypeSpecific.className = NULL,
        .number = AccountThreshold_FieldNumber_TxThreshold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountThreshold__storage_, txThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "typeThresholdsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationTypeThreshold),
        .number = AccountThreshold_FieldNumber_TypeThresholdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountThreshold__storage_, typeThresholdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountThreshold class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountThreshold__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationIssueAsset

@implementation OperationIssueAsset

@dynamic code;
@dynamic amount;

typedef struct OperationIssueAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
  int64_t amount;
} OperationIssueAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = OperationIssueAsset_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationIssueAsset__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = OperationIssueAsset_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperationIssueAsset__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationIssueAsset class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationIssueAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationPayCoin

@implementation OperationPayCoin

@dynamic destAddress;
@dynamic amount;
@dynamic input;

typedef struct OperationPayCoin__storage_ {
  uint32_t _has_storage_[1];
  NSString *destAddress;
  NSString *input;
  int64_t amount;
} OperationPayCoin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "destAddress",
        .dataTypeSpecific.className = NULL,
        .number = OperationPayCoin_FieldNumber_DestAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationPayCoin__storage_, destAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = OperationPayCoin_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperationPayCoin__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "input",
        .dataTypeSpecific.className = NULL,
        .number = OperationPayCoin_FieldNumber_Input,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OperationPayCoin__storage_, input),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationPayCoin class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationPayCoin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationSetSignerWeight

@implementation OperationSetSignerWeight

@dynamic masterWeight;
@dynamic signersArray, signersArray_Count;

typedef struct OperationSetSignerWeight__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *signersArray;
  int64_t masterWeight;
} OperationSetSignerWeight__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterWeight",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetSignerWeight_FieldNumber_MasterWeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationSetSignerWeight__storage_, masterWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "signersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signer),
        .number = OperationSetSignerWeight_FieldNumber_SignersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OperationSetSignerWeight__storage_, signersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationSetSignerWeight class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationSetSignerWeight__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationLog

@implementation OperationLog

@dynamic topic;
@dynamic datasArray, datasArray_Count;

typedef struct OperationLog__storage_ {
  uint32_t _has_storage_[1];
  NSString *topic;
  NSMutableArray *datasArray;
} OperationLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topic",
        .dataTypeSpecific.className = NULL,
        .number = OperationLog_FieldNumber_Topic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationLog__storage_, topic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "datasArray",
        .dataTypeSpecific.className = NULL,
        .number = OperationLog_FieldNumber_DatasArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OperationLog__storage_, datasArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationLog class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationSetPrivilege

@implementation OperationSetPrivilege

@dynamic masterWeight;
@dynamic signersArray, signersArray_Count;
@dynamic txThreshold;
@dynamic typeThresholdsArray, typeThresholdsArray_Count;

typedef struct OperationSetPrivilege__storage_ {
  uint32_t _has_storage_[1];
  NSString *masterWeight;
  NSMutableArray *signersArray;
  NSString *txThreshold;
  NSMutableArray *typeThresholdsArray;
} OperationSetPrivilege__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterWeight",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetPrivilege_FieldNumber_MasterWeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationSetPrivilege__storage_, masterWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signer),
        .number = OperationSetPrivilege_FieldNumber_SignersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OperationSetPrivilege__storage_, signersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txThreshold",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetPrivilege_FieldNumber_TxThreshold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperationSetPrivilege__storage_, txThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "typeThresholdsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationTypeThreshold),
        .number = OperationSetPrivilege_FieldNumber_TypeThresholdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OperationSetPrivilege__storage_, typeThresholdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationSetPrivilege class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationSetPrivilege__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Operation

@implementation Operation

@dynamic type;
@dynamic sourceAddress;
@dynamic metadata;
@dynamic hasCreateAccount, createAccount;
@dynamic hasIssueAsset, issueAsset;
@dynamic hasPayAsset, payAsset;
@dynamic hasSetMetadata, setMetadata;
@dynamic hasSetSignerWeight, setSignerWeight;
@dynamic hasSetThreshold, setThreshold;
@dynamic hasPayCoin, payCoin;
@dynamic hasLog, log;
@dynamic hasSetPrivilege, setPrivilege;

typedef struct Operation__storage_ {
  uint32_t _has_storage_[1];
  Operation_Type type;
  NSString *sourceAddress;
  NSData *metadata;
  OperationCreateAccount *createAccount;
  OperationIssueAsset *issueAsset;
  OperationPayAsset *payAsset;
  OperationSetMetadata *setMetadata;
  OperationSetSignerWeight *setSignerWeight;
  OperationSetThreshold *setThreshold;
  OperationPayCoin *payCoin;
  OperationLog *log;
  OperationSetPrivilege *setPrivilege;
} Operation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Operation_Type_EnumDescriptor,
        .number = Operation_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Operation__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sourceAddress",
        .dataTypeSpecific.className = NULL,
        .number = Operation_FieldNumber_SourceAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Operation__storage_, sourceAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = Operation_FieldNumber_Metadata,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Operation__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createAccount",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationCreateAccount),
        .number = Operation_FieldNumber_CreateAccount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Operation__storage_, createAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "issueAsset",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationIssueAsset),
        .number = Operation_FieldNumber_IssueAsset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Operation__storage_, issueAsset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payAsset",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationPayAsset),
        .number = Operation_FieldNumber_PayAsset,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Operation__storage_, payAsset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setMetadata",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationSetMetadata),
        .number = Operation_FieldNumber_SetMetadata,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Operation__storage_, setMetadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setSignerWeight",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationSetSignerWeight),
        .number = Operation_FieldNumber_SetSignerWeight,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Operation__storage_, setSignerWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setThreshold",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationSetThreshold),
        .number = Operation_FieldNumber_SetThreshold,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Operation__storage_, setThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payCoin",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationPayCoin),
        .number = Operation_FieldNumber_PayCoin,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Operation__storage_, payCoin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "log",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationLog),
        .number = Operation_FieldNumber_Log,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Operation__storage_, log),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setPrivilege",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationSetPrivilege),
        .number = Operation_FieldNumber_SetPrivilege,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Operation__storage_, setPrivilege),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Operation class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Operation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Operation_Type_RawValue(Operation *message) {
  GPBDescriptor *descriptor = [Operation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Operation_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetOperation_Type_RawValue(Operation *message, int32_t value) {
  GPBDescriptor *descriptor = [Operation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Operation_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Operation_Type

GPBEnumDescriptor *Operation_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000CreateAccount\000IssueAsset\000PayAsse"
        "t\000SetMetadata\000SetSignerWeight\000SetThresho"
        "ld\000PayCoin\000Log\000SetPrivilege\000";
    static const int32_t values[] = {
        Operation_Type_Unknown,
        Operation_Type_CreateAccount,
        Operation_Type_IssueAsset,
        Operation_Type_PayAsset,
        Operation_Type_SetMetadata,
        Operation_Type_SetSignerWeight,
        Operation_Type_SetThreshold,
        Operation_Type_PayCoin,
        Operation_Type_Log,
        Operation_Type_SetPrivilege,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Operation_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Operation_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Operation_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Operation_Type_Unknown:
    case Operation_Type_CreateAccount:
    case Operation_Type_IssueAsset:
    case Operation_Type_PayAsset:
    case Operation_Type_SetMetadata:
    case Operation_Type_SetSignerWeight:
    case Operation_Type_SetThreshold:
    case Operation_Type_PayCoin:
    case Operation_Type_Log:
    case Operation_Type_SetPrivilege:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - OperationSetThreshold

@implementation OperationSetThreshold

@dynamic txThreshold;
@dynamic typeThresholdsArray, typeThresholdsArray_Count;

typedef struct OperationSetThreshold__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *typeThresholdsArray;
  int64_t txThreshold;
} OperationSetThreshold__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txThreshold",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetThreshold_FieldNumber_TxThreshold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationSetThreshold__storage_, txThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "typeThresholdsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OperationTypeThreshold),
        .number = OperationSetThreshold_FieldNumber_TypeThresholdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OperationSetThreshold__storage_, typeThresholdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationSetThreshold class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationSetThreshold__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic sourceAddress;
@dynamic nonce;
@dynamic feeLimit;
@dynamic gasPrice;
@dynamic ceilLedgerSeq;
@dynamic metadata;
@dynamic operationsArray, operationsArray_Count;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  NSString *sourceAddress;
  NSData *metadata;
  NSMutableArray *operationsArray;
  int64_t nonce;
  int64_t feeLimit;
  int64_t gasPrice;
  int64_t ceilLedgerSeq;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceAddress",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_SourceAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, sourceAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Nonce,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeLimit",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_FeeLimit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, feeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gasPrice",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_GasPrice,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, gasPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ceilLedgerSeq",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_CeilLedgerSeq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, ceilLedgerSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Metadata,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "operationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Operation),
        .number = Transaction_FieldNumber_OperationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, operationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Transaction_Limit

GPBEnumDescriptor *Transaction_Limit_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Operations\000";
    static const int32_t values[] = {
        Transaction_Limit_Unknown,
        Transaction_Limit_Operations,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Limit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Limit_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Limit_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Limit_Unknown:
    case Transaction_Limit_Operations:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Signer

@implementation Signer

@dynamic address;
@dynamic weight;

typedef struct Signer__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  int64_t weight;
} Signer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Signer_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signer__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = Signer_FieldNumber_Weight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signer__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signer class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Signer_Limit

GPBEnumDescriptor *Signer_Limit_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SignerNone\000Signer\000";
    static const int32_t values[] = {
        Signer_Limit_SignerNone,
        Signer_Limit_Signer,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Signer_Limit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Signer_Limit_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Signer_Limit_IsValidValue(int32_t value__) {
  switch (value__) {
    case Signer_Limit_SignerNone:
    case Signer_Limit_Signer:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Trigger

@implementation Trigger

@dynamic transactionType;
@dynamic ledgerSeq;
@dynamic hasTransaction, transaction;

typedef struct Trigger__storage_ {
  uint32_t _has_storage_[1];
  Trigger_TransactionType transactionType;
  Trigger_OperationTrigger *transaction;
  int64_t ledgerSeq;
} Trigger__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionType",
        .dataTypeSpecific.enumDescFunc = Trigger_TransactionType_EnumDescriptor,
        .number = Trigger_FieldNumber_TransactionType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Trigger__storage_, transactionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ledgerSeq",
        .dataTypeSpecific.className = NULL,
        .number = Trigger_FieldNumber_LedgerSeq,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Trigger__storage_, ledgerSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(Trigger_OperationTrigger),
        .number = Trigger_FieldNumber_Transaction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Trigger__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Trigger class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Trigger__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Trigger_TransactionType_RawValue(Trigger *message) {
  GPBDescriptor *descriptor = [Trigger descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trigger_FieldNumber_TransactionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetTrigger_TransactionType_RawValue(Trigger *message, int32_t value) {
  GPBDescriptor *descriptor = [Trigger descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Trigger_FieldNumber_TransactionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Trigger_TransactionType

GPBEnumDescriptor *Trigger_TransactionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NormalTransaction\000ContractTransaction\000";
    static const int32_t values[] = {
        Trigger_TransactionType_NormalTransaction,
        Trigger_TransactionType_ContractTransaction,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Trigger_TransactionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Trigger_TransactionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Trigger_TransactionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Trigger_TransactionType_NormalTransaction:
    case Trigger_TransactionType_ContractTransaction:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Trigger_OperationTrigger

@implementation Trigger_OperationTrigger

@dynamic hash_p;
@dynamic index;

typedef struct Trigger_OperationTrigger__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t index;
} Trigger_OperationTrigger__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = Trigger_OperationTrigger_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Trigger_OperationTrigger__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = Trigger_OperationTrigger_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Trigger_OperationTrigger__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Trigger_OperationTrigger class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Trigger_OperationTrigger__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Trigger)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionEnv

@implementation TransactionEnv

@dynamic hasTransaction, transaction;
@dynamic signaturesArray, signaturesArray_Count;
@dynamic hasTrigger, trigger;

typedef struct TransactionEnv__storage_ {
  uint32_t _has_storage_[1];
  Transaction *transaction;
  NSMutableArray *signaturesArray;
  Trigger *trigger;
} TransactionEnv__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionEnv_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionEnv__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signaturesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = TransactionEnv_FieldNumber_SignaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionEnv__storage_, signaturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trigger",
        .dataTypeSpecific.className = GPBStringifySymbol(Trigger),
        .number = TransactionEnv_FieldNumber_Trigger,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionEnv__storage_, trigger),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionEnv class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionEnv__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionEnvStore

@implementation TransactionEnvStore

@dynamic hasTransactionEnv, transactionEnv;
@dynamic errorCode;
@dynamic errorDesc;
@dynamic ledgerSeq;
@dynamic closeTime;
@dynamic hash_p;
@dynamic actualFee;

typedef struct TransactionEnvStore__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  TransactionEnv *transactionEnv;
  NSString *errorDesc;
  NSData *hash_p;
  int64_t ledgerSeq;
  int64_t closeTime;
  int64_t actualFee;
} TransactionEnvStore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionEnv",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionEnv),
        .number = TransactionEnvStore_FieldNumber_TransactionEnv,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionEnvStore__storage_, transactionEnv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = TransactionEnvStore_FieldNumber_ErrorCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionEnvStore__storage_, errorCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errorDesc",
        .dataTypeSpecific.className = NULL,
        .number = TransactionEnvStore_FieldNumber_ErrorDesc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionEnvStore__storage_, errorDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ledgerSeq",
        .dataTypeSpecific.className = NULL,
        .number = TransactionEnvStore_FieldNumber_LedgerSeq,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransactionEnvStore__storage_, ledgerSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closeTime",
        .dataTypeSpecific.className = NULL,
        .number = TransactionEnvStore_FieldNumber_CloseTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransactionEnvStore__storage_, closeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = TransactionEnvStore_FieldNumber_Hash_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TransactionEnvStore__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "actualFee",
        .dataTypeSpecific.className = NULL,
        .number = TransactionEnvStore_FieldNumber_ActualFee,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TransactionEnvStore__storage_, actualFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionEnvStore class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionEnvStore__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionEnvSet

@implementation TransactionEnvSet

@dynamic txsArray, txsArray_Count;

typedef struct TransactionEnvSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
} TransactionEnvSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionEnv),
        .number = TransactionEnvSet_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionEnvSet__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionEnvSet class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionEnvSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConsensusValueValidation

@implementation ConsensusValueValidation

@dynamic expireTxIdsArray, expireTxIdsArray_Count;
@dynamic errorTxIdsArray, errorTxIdsArray_Count;

typedef struct ConsensusValueValidation__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *expireTxIdsArray;
  GPBInt32Array *errorTxIdsArray;
} ConsensusValueValidation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "expireTxIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ConsensusValueValidation_FieldNumber_ExpireTxIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConsensusValueValidation__storage_, expireTxIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errorTxIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ConsensusValueValidation_FieldNumber_ErrorTxIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConsensusValueValidation__storage_, errorTxIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConsensusValueValidation class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConsensusValueValidation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConsensusValue

@implementation ConsensusValue

@dynamic hasTxset, txset;
@dynamic closeTime;
@dynamic previousProof;
@dynamic ledgerSeq;
@dynamic previousLedgerHash;
@dynamic hasLedgerUpgrade, ledgerUpgrade;
@dynamic hasValidation, validation;

typedef struct ConsensusValue__storage_ {
  uint32_t _has_storage_[1];
  TransactionEnvSet *txset;
  NSData *previousProof;
  NSData *previousLedgerHash;
  LedgerUpgrade *ledgerUpgrade;
  ConsensusValueValidation *validation;
  int64_t closeTime;
  int64_t ledgerSeq;
} ConsensusValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txset",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionEnvSet),
        .number = ConsensusValue_FieldNumber_Txset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConsensusValue__storage_, txset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closeTime",
        .dataTypeSpecific.className = NULL,
        .number = ConsensusValue_FieldNumber_CloseTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConsensusValue__storage_, closeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "previousProof",
        .dataTypeSpecific.className = NULL,
        .number = ConsensusValue_FieldNumber_PreviousProof,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConsensusValue__storage_, previousProof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ledgerSeq",
        .dataTypeSpecific.className = NULL,
        .number = ConsensusValue_FieldNumber_LedgerSeq,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ConsensusValue__storage_, ledgerSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "previousLedgerHash",
        .dataTypeSpecific.className = NULL,
        .number = ConsensusValue_FieldNumber_PreviousLedgerHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ConsensusValue__storage_, previousLedgerHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ledgerUpgrade",
        .dataTypeSpecific.className = GPBStringifySymbol(LedgerUpgrade),
        .number = ConsensusValue_FieldNumber_LedgerUpgrade,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ConsensusValue__storage_, ledgerUpgrade),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validation",
        .dataTypeSpecific.className = GPBStringifySymbol(ConsensusValueValidation),
        .number = ConsensusValue_FieldNumber_Validation,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ConsensusValue__storage_, validation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConsensusValue class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConsensusValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Contract

@implementation Contract

@dynamic type;
@dynamic payload;

typedef struct Contract__storage_ {
  uint32_t _has_storage_[1];
  Contract_ContractType type;
  NSString *payload;
} Contract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Contract_ContractType_EnumDescriptor,
        .number = Contract_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Contract__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = NULL,
        .number = Contract_FieldNumber_Payload,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Contract__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Contract class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Contract__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Contract_Type_RawValue(Contract *message) {
  GPBDescriptor *descriptor = [Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Contract_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetContract_Type_RawValue(Contract *message, int32_t value) {
  GPBDescriptor *descriptor = [Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Contract_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Contract_ContractType

GPBEnumDescriptor *Contract_ContractType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Javascript\000";
    static const int32_t values[] = {
        Contract_ContractType_Javascript,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Contract_ContractType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Contract_ContractType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Contract_ContractType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Contract_ContractType_Javascript:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - OperationCreateAccount

@implementation OperationCreateAccount

@dynamic destAddress;
@dynamic hasContract, contract;
@dynamic hasPriv, priv;
@dynamic metadatasArray, metadatasArray_Count;
@dynamic initBalance;
@dynamic initInput;

typedef struct OperationCreateAccount__storage_ {
  uint32_t _has_storage_[1];
  NSString *destAddress;
  Contract *contract;
  AccountPrivilege *priv;
  NSMutableArray *metadatasArray;
  NSString *initInput;
  int64_t initBalance;
} OperationCreateAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "destAddress",
        .dataTypeSpecific.className = NULL,
        .number = OperationCreateAccount_FieldNumber_DestAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationCreateAccount__storage_, destAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contract",
        .dataTypeSpecific.className = GPBStringifySymbol(Contract),
        .number = OperationCreateAccount_FieldNumber_Contract,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperationCreateAccount__storage_, contract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "priv",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountPrivilege),
        .number = OperationCreateAccount_FieldNumber_Priv,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OperationCreateAccount__storage_, priv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadatasArray",
        .dataTypeSpecific.className = GPBStringifySymbol(KeyPair),
        .number = OperationCreateAccount_FieldNumber_MetadatasArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OperationCreateAccount__storage_, metadatasArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initBalance",
        .dataTypeSpecific.className = NULL,
        .number = OperationCreateAccount_FieldNumber_InitBalance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OperationCreateAccount__storage_, initBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "initInput",
        .dataTypeSpecific.className = NULL,
        .number = OperationCreateAccount_FieldNumber_InitInput,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OperationCreateAccount__storage_, initInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationCreateAccount class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationCreateAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OperationSetMetadata

@implementation OperationSetMetadata

@dynamic key;
@dynamic value;
@dynamic version;
@dynamic deleteFlag;

typedef struct OperationSetMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
  int64_t version;
} OperationSetMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetMetadata_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OperationSetMetadata__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetMetadata_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OperationSetMetadata__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetMetadata_FieldNumber_Version,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OperationSetMetadata__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deleteFlag",
        .dataTypeSpecific.className = NULL,
        .number = OperationSetMetadata_FieldNumber_DeleteFlag,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OperationSetMetadata class]
                                     rootClass:[ChainRoot class]
                                          file:ChainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OperationSetMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
