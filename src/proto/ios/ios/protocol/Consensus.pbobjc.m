// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: consensus.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Consensus.pbobjc.h"
 #import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ConsensusRoot

@implementation ConsensusRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ConsensusRoot_FileDescriptor

static GPBFileDescriptor *ConsensusRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PbftMessageType

GPBEnumDescriptor *PbftMessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PbftTypePreprepare\000PbftTypePrepare\000PbftT"
        "ypeCommit\000PbftTypeViewchange\000PbftTypeNew"
        "view\000PbftTypeViewchangWithRawvalue\000";
    static const int32_t values[] = {
        PbftMessageType_PbftTypePreprepare,
        PbftMessageType_PbftTypePrepare,
        PbftMessageType_PbftTypeCommit,
        PbftMessageType_PbftTypeViewchange,
        PbftMessageType_PbftTypeNewview,
        PbftMessageType_PbftTypeViewchangWithRawvalue,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbftMessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbftMessageType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbftMessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbftMessageType_PbftTypePreprepare:
    case PbftMessageType_PbftTypePrepare:
    case PbftMessageType_PbftTypeCommit:
    case PbftMessageType_PbftTypeViewchange:
    case PbftMessageType_PbftTypeNewview:
    case PbftMessageType_PbftTypeViewchangWithRawvalue:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbftValueType

GPBEnumDescriptor *PbftValueType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PbftValueTx\000PbftValueTxset\000";
    static const int32_t values[] = {
        PbftValueType_PbftValueTx,
        PbftValueType_PbftValueTxset,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbftValueType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbftValueType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbftValueType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbftValueType_PbftValueTx:
    case PbftValueType_PbftValueTxset:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbftPrePrepare

@implementation PbftPrePrepare

@dynamic viewNumber;
@dynamic sequence;
@dynamic replicaId;
@dynamic value;
@dynamic valueDigest;

typedef struct PbftPrePrepare__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
  NSData *valueDigest;
  int64_t viewNumber;
  int64_t sequence;
  int64_t replicaId;
} PbftPrePrepare__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewNumber",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrePrepare_FieldNumber_ViewNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftPrePrepare__storage_, viewNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrePrepare_FieldNumber_Sequence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbftPrePrepare__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "replicaId",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrePrepare_FieldNumber_ReplicaId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbftPrePrepare__storage_, replicaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrePrepare_FieldNumber_Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbftPrePrepare__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "valueDigest",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrePrepare_FieldNumber_ValueDigest,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbftPrePrepare__storage_, valueDigest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftPrePrepare class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftPrePrepare__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbftPrepare

@implementation PbftPrepare

@dynamic viewNumber;
@dynamic sequence;
@dynamic replicaId;
@dynamic valueDigest;

typedef struct PbftPrepare__storage_ {
  uint32_t _has_storage_[1];
  NSData *valueDigest;
  int64_t viewNumber;
  int64_t sequence;
  int64_t replicaId;
} PbftPrepare__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewNumber",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrepare_FieldNumber_ViewNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftPrepare__storage_, viewNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrepare_FieldNumber_Sequence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbftPrepare__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "replicaId",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrepare_FieldNumber_ReplicaId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbftPrepare__storage_, replicaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "valueDigest",
        .dataTypeSpecific.className = NULL,
        .number = PbftPrepare_FieldNumber_ValueDigest,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbftPrepare__storage_, valueDigest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftPrepare class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftPrepare__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbftCommit

@implementation PbftCommit

@dynamic viewNumber;
@dynamic sequence;
@dynamic replicaId;
@dynamic valueDigest;

typedef struct PbftCommit__storage_ {
  uint32_t _has_storage_[1];
  NSData *valueDigest;
  int64_t viewNumber;
  int64_t sequence;
  int64_t replicaId;
} PbftCommit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewNumber",
        .dataTypeSpecific.className = NULL,
        .number = PbftCommit_FieldNumber_ViewNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftCommit__storage_, viewNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = PbftCommit_FieldNumber_Sequence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbftCommit__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "replicaId",
        .dataTypeSpecific.className = NULL,
        .number = PbftCommit_FieldNumber_ReplicaId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbftCommit__storage_, replicaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "valueDigest",
        .dataTypeSpecific.className = NULL,
        .number = PbftCommit_FieldNumber_ValueDigest,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbftCommit__storage_, valueDigest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftCommit class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftCommit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbftPreparedSet

@implementation PbftPreparedSet

@dynamic hasPrePrepare, prePrepare;
@dynamic prepareArray, prepareArray_Count;

typedef struct PbftPreparedSet__storage_ {
  uint32_t _has_storage_[1];
  PbftEnv *prePrepare;
  NSMutableArray *prepareArray;
} PbftPreparedSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prePrepare",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftEnv),
        .number = PbftPreparedSet_FieldNumber_PrePrepare,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftPreparedSet__storage_, prePrepare),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prepareArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftEnv),
        .number = PbftPreparedSet_FieldNumber_PrepareArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbftPreparedSet__storage_, prepareArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftPreparedSet class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftPreparedSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbftViewChange

@implementation PbftViewChange

@dynamic viewNumber;
@dynamic sequence;
@dynamic prepredValueDigest;
@dynamic replicaId;

typedef struct PbftViewChange__storage_ {
  uint32_t _has_storage_[1];
  NSData *prepredValueDigest;
  int64_t viewNumber;
  int64_t sequence;
  int64_t replicaId;
} PbftViewChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewNumber",
        .dataTypeSpecific.className = NULL,
        .number = PbftViewChange_FieldNumber_ViewNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftViewChange__storage_, viewNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = PbftViewChange_FieldNumber_Sequence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbftViewChange__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prepredValueDigest",
        .dataTypeSpecific.className = NULL,
        .number = PbftViewChange_FieldNumber_PrepredValueDigest,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbftViewChange__storage_, prepredValueDigest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "replicaId",
        .dataTypeSpecific.className = NULL,
        .number = PbftViewChange_FieldNumber_ReplicaId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbftViewChange__storage_, replicaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftViewChange class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftViewChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbftViewChangeWithRawValue

@implementation PbftViewChangeWithRawValue

@dynamic hasViewChangeEnv, viewChangeEnv;
@dynamic hasPreparedSet, preparedSet;

typedef struct PbftViewChangeWithRawValue__storage_ {
  uint32_t _has_storage_[1];
  PbftEnv *viewChangeEnv;
  PbftPreparedSet *preparedSet;
} PbftViewChangeWithRawValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewChangeEnv",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftEnv),
        .number = PbftViewChangeWithRawValue_FieldNumber_ViewChangeEnv,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftViewChangeWithRawValue__storage_, viewChangeEnv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preparedSet",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftPreparedSet),
        .number = PbftViewChangeWithRawValue_FieldNumber_PreparedSet,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbftViewChangeWithRawValue__storage_, preparedSet),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftViewChangeWithRawValue class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftViewChangeWithRawValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbftNewView

@implementation PbftNewView

@dynamic viewNumber;
@dynamic sequence;
@dynamic replicaId;
@dynamic viewChangesArray, viewChangesArray_Count;
@dynamic hasPrePrepare, prePrepare;

typedef struct PbftNewView__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *viewChangesArray;
  PbftEnv *prePrepare;
  int64_t viewNumber;
  int64_t sequence;
  int64_t replicaId;
} PbftNewView__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewNumber",
        .dataTypeSpecific.className = NULL,
        .number = PbftNewView_FieldNumber_ViewNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftNewView__storage_, viewNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = PbftNewView_FieldNumber_Sequence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbftNewView__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "replicaId",
        .dataTypeSpecific.className = NULL,
        .number = PbftNewView_FieldNumber_ReplicaId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbftNewView__storage_, replicaId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "viewChangesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftEnv),
        .number = PbftNewView_FieldNumber_ViewChangesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbftNewView__storage_, viewChangesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prePrepare",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftEnv),
        .number = PbftNewView_FieldNumber_PrePrepare,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbftNewView__storage_, prePrepare),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftNewView class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftNewView__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Pbft

@implementation Pbft

@dynamic roundNumber;
@dynamic type;
@dynamic hasPrePrepare, prePrepare;
@dynamic hasPrepare, prepare;
@dynamic hasCommit, commit;
@dynamic hasViewChange, viewChange;
@dynamic hasNewView, newView;
@dynamic hasViewChangeWithRawvalue, viewChangeWithRawvalue;

typedef struct Pbft__storage_ {
  uint32_t _has_storage_[1];
  PbftMessageType type;
  PbftPrePrepare *prePrepare;
  PbftPrepare *prepare;
  PbftCommit *commit;
  PbftViewChange *viewChange;
  PbftNewView *newView;
  PbftViewChangeWithRawValue *viewChangeWithRawvalue;
  int64_t roundNumber;
} Pbft__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roundNumber",
        .dataTypeSpecific.className = NULL,
        .number = Pbft_FieldNumber_RoundNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Pbft__storage_, roundNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PbftMessageType_EnumDescriptor,
        .number = Pbft_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Pbft__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "prePrepare",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftPrePrepare),
        .number = Pbft_FieldNumber_PrePrepare,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Pbft__storage_, prePrepare),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prepare",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftPrepare),
        .number = Pbft_FieldNumber_Prepare,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Pbft__storage_, prepare),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commit",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftCommit),
        .number = Pbft_FieldNumber_Commit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Pbft__storage_, commit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "viewChange",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftViewChange),
        .number = Pbft_FieldNumber_ViewChange,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Pbft__storage_, viewChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newView",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftNewView),
        .number = Pbft_FieldNumber_NewView,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Pbft__storage_, newView),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "viewChangeWithRawvalue",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftViewChangeWithRawValue),
        .number = Pbft_FieldNumber_ViewChangeWithRawvalue,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Pbft__storage_, viewChangeWithRawvalue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Pbft class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Pbft__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Pbft_Type_RawValue(Pbft *message) {
  GPBDescriptor *descriptor = [Pbft descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Pbft_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPbft_Type_RawValue(Pbft *message, int32_t value) {
  GPBDescriptor *descriptor = [Pbft descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Pbft_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PbftEnv

@implementation PbftEnv

@dynamic hasPbft, pbft;
@dynamic hasSignature, signature;

typedef struct PbftEnv__storage_ {
  uint32_t _has_storage_[1];
  Pbft *pbft;
  Signature *signature;
} PbftEnv__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pbft",
        .dataTypeSpecific.className = GPBStringifySymbol(Pbft),
        .number = PbftEnv_FieldNumber_Pbft,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbftEnv__storage_, pbft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = PbftEnv_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbftEnv__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftEnv class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftEnv__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Validator

@implementation Validator

@dynamic address;
@dynamic pledgeCoinAmount;

typedef struct Validator__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  int64_t pledgeCoinAmount;
} Validator__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Validator_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Validator__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pledgeCoinAmount",
        .dataTypeSpecific.className = NULL,
        .number = Validator_FieldNumber_PledgeCoinAmount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Validator__storage_, pledgeCoinAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Validator class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Validator__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorSet

@implementation ValidatorSet

@dynamic validatorsArray, validatorsArray_Count;

typedef struct ValidatorSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *validatorsArray;
} ValidatorSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validatorsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Validator),
        .number = ValidatorSet_FieldNumber_ValidatorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValidatorSet__storage_, validatorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ValidatorSet class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbftProof

@implementation PbftProof

@dynamic commitsArray, commitsArray_Count;

typedef struct PbftProof__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *commitsArray;
} PbftProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commitsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbftEnv),
        .number = PbftProof_FieldNumber_CommitsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbftProof__storage_, commitsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbftProof class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbftProof__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeeConfig

@implementation FeeConfig

@dynamic gasPrice;
@dynamic baseReserve;

typedef struct FeeConfig__storage_ {
  uint32_t _has_storage_[1];
  int64_t gasPrice;
  int64_t baseReserve;
} FeeConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gasPrice",
        .dataTypeSpecific.className = NULL,
        .number = FeeConfig_FieldNumber_GasPrice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FeeConfig__storage_, gasPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "baseReserve",
        .dataTypeSpecific.className = NULL,
        .number = FeeConfig_FieldNumber_BaseReserve,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FeeConfig__storage_, baseReserve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeeConfig class]
                                     rootClass:[ConsensusRoot class]
                                          file:ConsensusRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeeConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum FeeConfig_Type

GPBEnumDescriptor *FeeConfig_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000GasPrice\000BaseReserve\000";
    static const int32_t values[] = {
        FeeConfig_Type_Unknown,
        FeeConfig_Type_GasPrice,
        FeeConfig_Type_BaseReserve,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FeeConfig_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FeeConfig_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FeeConfig_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case FeeConfig_Type_Unknown:
    case FeeConfig_Type_GasPrice:
    case FeeConfig_Type_BaseReserve:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
