// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: overlay.proto

#ifndef PROTOBUF_overlay_2eproto__INCLUDED
#define PROTOBUF_overlay_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "chain.pb.h"
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_overlay_2eproto();
void protobuf_AssignDesc_overlay_2eproto();
void protobuf_ShutdownFile_overlay_2eproto();

class ChainHello;
class ChainInfoMessage;
class ChainPeerMessage;
class ChainResponse;
class ChainStatus;
class ChainSubscribeTx;
class ChainTxStatus;
class DontHave;
class EntryList;
class GetLedgers;
class Hello;
class HelloResponse;
class LedgerUpgradeNotify;
class Ledgers;
class Peer;
class Peers;

enum Ledgers_SyncCode {
  Ledgers_SyncCode_OK = 0,
  Ledgers_SyncCode_OUT_OF_SYNC = 1,
  Ledgers_SyncCode_OUT_OF_LEDGERS = 2,
  Ledgers_SyncCode_BUSY = 3,
  Ledgers_SyncCode_REFUSE = 4,
  Ledgers_SyncCode_INTERNAL = 5,
  Ledgers_SyncCode_Ledgers_SyncCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Ledgers_SyncCode_Ledgers_SyncCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Ledgers_SyncCode_IsValid(int value);
const Ledgers_SyncCode Ledgers_SyncCode_SyncCode_MIN = Ledgers_SyncCode_OK;
const Ledgers_SyncCode Ledgers_SyncCode_SyncCode_MAX = Ledgers_SyncCode_INTERNAL;
const int Ledgers_SyncCode_SyncCode_ARRAYSIZE = Ledgers_SyncCode_SyncCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ledgers_SyncCode_descriptor();
inline const ::std::string& Ledgers_SyncCode_Name(Ledgers_SyncCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ledgers_SyncCode_descriptor(), value);
}
inline bool Ledgers_SyncCode_Parse(
    const ::std::string& name, Ledgers_SyncCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ledgers_SyncCode>(
    Ledgers_SyncCode_descriptor(), name, value);
}
enum ChainTxStatus_TxStatus {
  ChainTxStatus_TxStatus_UNDEFINED = 0,
  ChainTxStatus_TxStatus_CONFIRMED = 1,
  ChainTxStatus_TxStatus_PENDING = 2,
  ChainTxStatus_TxStatus_COMPLETE = 3,
  ChainTxStatus_TxStatus_FAILURE = 4,
  ChainTxStatus_TxStatus_ChainTxStatus_TxStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChainTxStatus_TxStatus_ChainTxStatus_TxStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChainTxStatus_TxStatus_IsValid(int value);
const ChainTxStatus_TxStatus ChainTxStatus_TxStatus_TxStatus_MIN = ChainTxStatus_TxStatus_UNDEFINED;
const ChainTxStatus_TxStatus ChainTxStatus_TxStatus_TxStatus_MAX = ChainTxStatus_TxStatus_FAILURE;
const int ChainTxStatus_TxStatus_TxStatus_ARRAYSIZE = ChainTxStatus_TxStatus_TxStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChainTxStatus_TxStatus_descriptor();
inline const ::std::string& ChainTxStatus_TxStatus_Name(ChainTxStatus_TxStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChainTxStatus_TxStatus_descriptor(), value);
}
inline bool ChainTxStatus_TxStatus_Parse(
    const ::std::string& name, ChainTxStatus_TxStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChainTxStatus_TxStatus>(
    ChainTxStatus_TxStatus_descriptor(), name, value);
}
enum OVERLAY_MESSAGE_TYPE {
  OVERLAY_MSGTYPE_NONE = 0,
  OVERLAY_MSGTYPE_PING = 1,
  OVERLAY_MSGTYPE_HELLO = 2,
  OVERLAY_MSGTYPE_PEERS = 3,
  OVERLAY_MSGTYPE_TRANSACTION = 4,
  OVERLAY_MSGTYPE_LEDGERS = 5,
  OVERLAY_MSGTYPE_PBFT = 6,
  OVERLAY_MSGTYPE_LEDGER_UPGRADE_NOTIFY = 7,
  OVERLAY_MESSAGE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OVERLAY_MESSAGE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OVERLAY_MESSAGE_TYPE_IsValid(int value);
const OVERLAY_MESSAGE_TYPE OVERLAY_MESSAGE_TYPE_MIN = OVERLAY_MSGTYPE_NONE;
const OVERLAY_MESSAGE_TYPE OVERLAY_MESSAGE_TYPE_MAX = OVERLAY_MSGTYPE_LEDGER_UPGRADE_NOTIFY;
const int OVERLAY_MESSAGE_TYPE_ARRAYSIZE = OVERLAY_MESSAGE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* OVERLAY_MESSAGE_TYPE_descriptor();
inline const ::std::string& OVERLAY_MESSAGE_TYPE_Name(OVERLAY_MESSAGE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    OVERLAY_MESSAGE_TYPE_descriptor(), value);
}
inline bool OVERLAY_MESSAGE_TYPE_Parse(
    const ::std::string& name, OVERLAY_MESSAGE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OVERLAY_MESSAGE_TYPE>(
    OVERLAY_MESSAGE_TYPE_descriptor(), name, value);
}
enum ChainMessageType {
  CHAIN_TYPE_NONE = 0,
  CHAIN_HELLO = 10,
  CHAIN_TX_STATUS = 11,
  CHAIN_PEER_ONLINE = 12,
  CHAIN_PEER_OFFLINE = 13,
  CHAIN_PEER_MESSAGE = 14,
  CHAIN_SUBMITTRANSACTION = 15,
  CHAIN_LEDGER_HEADER = 16,
  CHAIN_SUBSCRIBE_TX = 17,
  CHAIN_TX_ENV_STORE = 18,
  ChainMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChainMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChainMessageType_IsValid(int value);
const ChainMessageType ChainMessageType_MIN = CHAIN_TYPE_NONE;
const ChainMessageType ChainMessageType_MAX = CHAIN_TX_ENV_STORE;
const int ChainMessageType_ARRAYSIZE = ChainMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChainMessageType_descriptor();
inline const ::std::string& ChainMessageType_Name(ChainMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChainMessageType_descriptor(), value);
}
inline bool ChainMessageType_Parse(
    const ::std::string& name, ChainMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChainMessageType>(
    ChainMessageType_descriptor(), name, value);
}
// ===================================================================

class Hello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Hello) */ {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  inline Hello* New() const { return New(NULL); }

  Hello* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 network_id = 1;
  void clear_network_id();
  static const int kNetworkIdFieldNumber = 1;
  ::google::protobuf::int64 network_id() const;
  void set_network_id(::google::protobuf::int64 value);

  // optional int64 ledger_version = 2;
  void clear_ledger_version();
  static const int kLedgerVersionFieldNumber = 2;
  ::google::protobuf::int64 ledger_version() const;
  void set_ledger_version(::google::protobuf::int64 value);

  // optional int64 overlay_version = 3;
  void clear_overlay_version();
  static const int kOverlayVersionFieldNumber = 3;
  ::google::protobuf::int64 overlay_version() const;
  void set_overlay_version(::google::protobuf::int64 value);

  // optional string CEG_version = 4;
  void clear_CEG_version();
  static const int kCEGVersionFieldNumber = 4;
  const ::std::string& CEG_version() const;
  void set_CEG_version(const ::std::string& value);
  void set_CEG_version(const char* value);
  void set_CEG_version(const char* value, size_t size);
  ::std::string* mutable_CEG_version();
  ::std::string* release_CEG_version();
  void set_allocated_CEG_version(::std::string* CEG_version);

  // optional int64 listening_port = 5;
  void clear_listening_port();
  static const int kListeningPortFieldNumber = 5;
  ::google::protobuf::int64 listening_port() const;
  void set_listening_port(::google::protobuf::int64 value);

  // optional string node_address = 6;
  void clear_node_address();
  static const int kNodeAddressFieldNumber = 6;
  const ::std::string& node_address() const;
  void set_node_address(const ::std::string& value);
  void set_node_address(const char* value);
  void set_node_address(const char* value, size_t size);
  ::std::string* mutable_node_address();
  ::std::string* release_node_address();
  void set_allocated_node_address(::std::string* node_address);

  // optional string node_rand = 7;
  void clear_node_rand();
  static const int kNodeRandFieldNumber = 7;
  const ::std::string& node_rand() const;
  void set_node_rand(const ::std::string& value);
  void set_node_rand(const char* value);
  void set_node_rand(const char* value, size_t size);
  ::std::string* mutable_node_rand();
  ::std::string* release_node_rand();
  void set_allocated_node_rand(::std::string* node_rand);

  // @@protoc_insertion_point(class_scope:protocol.Hello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 network_id_;
  ::google::protobuf::int64 ledger_version_;
  ::google::protobuf::int64 overlay_version_;
  ::google::protobuf::internal::ArenaStringPtr CEG_version_;
  ::google::protobuf::int64 listening_port_;
  ::google::protobuf::internal::ArenaStringPtr node_address_;
  ::google::protobuf::internal::ArenaStringPtr node_rand_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class HelloResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.HelloResponse) */ {
 public:
  HelloResponse();
  virtual ~HelloResponse();

  HelloResponse(const HelloResponse& from);

  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloResponse& default_instance();

  void Swap(HelloResponse* other);

  // implements Message ----------------------------------------------

  inline HelloResponse* New() const { return New(NULL); }

  HelloResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloResponse& from);
  void MergeFrom(const HelloResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HelloResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.ERRORCODE error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::protocol::ERRORCODE error_code() const;
  void set_error_code(::protocol::ERRORCODE value);

  // optional string error_desc = 2;
  void clear_error_desc();
  static const int kErrorDescFieldNumber = 2;
  const ::std::string& error_desc() const;
  void set_error_desc(const ::std::string& value);
  void set_error_desc(const char* value);
  void set_error_desc(const char* value, size_t size);
  ::std::string* mutable_error_desc();
  ::std::string* release_error_desc();
  void set_allocated_error_desc(::std::string* error_desc);

  // @@protoc_insertion_point(class_scope:protocol.HelloResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr error_desc_;
  int error_code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static HelloResponse* default_instance_;
};
// -------------------------------------------------------------------

class Peer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Peer) */ {
 public:
  Peer();
  virtual ~Peer();

  Peer(const Peer& from);

  inline Peer& operator=(const Peer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Peer& default_instance();

  void Swap(Peer* other);

  // implements Message ----------------------------------------------

  inline Peer* New() const { return New(NULL); }

  Peer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Peer& from);
  void MergeFrom(const Peer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Peer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional int64 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int64 port() const;
  void set_port(::google::protobuf::int64 value);

  // optional int64 num_failures = 3;
  void clear_num_failures();
  static const int kNumFailuresFieldNumber = 3;
  ::google::protobuf::int64 num_failures() const;
  void set_num_failures(::google::protobuf::int64 value);

  // optional int64 next_attempt_time = 4;
  void clear_next_attempt_time();
  static const int kNextAttemptTimeFieldNumber = 4;
  ::google::protobuf::int64 next_attempt_time() const;
  void set_next_attempt_time(::google::protobuf::int64 value);

  // optional int64 active_time = 5;
  void clear_active_time();
  static const int kActiveTimeFieldNumber = 5;
  ::google::protobuf::int64 active_time() const;
  void set_active_time(::google::protobuf::int64 value);

  // optional int64 connection_id = 6;
  void clear_connection_id();
  static const int kConnectionIdFieldNumber = 6;
  ::google::protobuf::int64 connection_id() const;
  void set_connection_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Peer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int64 port_;
  ::google::protobuf::int64 num_failures_;
  ::google::protobuf::int64 next_attempt_time_;
  ::google::protobuf::int64 active_time_;
  ::google::protobuf::int64 connection_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static Peer* default_instance_;
};
// -------------------------------------------------------------------

class Peers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Peers) */ {
 public:
  Peers();
  virtual ~Peers();

  Peers(const Peers& from);

  inline Peers& operator=(const Peers& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Peers& default_instance();

  void Swap(Peers* other);

  // implements Message ----------------------------------------------

  inline Peers* New() const { return New(NULL); }

  Peers* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Peers& from);
  void MergeFrom(const Peers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Peers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Peer peers = 1;
  int peers_size() const;
  void clear_peers();
  static const int kPeersFieldNumber = 1;
  const ::protocol::Peer& peers(int index) const;
  ::protocol::Peer* mutable_peers(int index);
  ::protocol::Peer* add_peers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Peer >*
      mutable_peers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Peer >&
      peers() const;

  // @@protoc_insertion_point(class_scope:protocol.Peers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Peer > peers_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static Peers* default_instance_;
};
// -------------------------------------------------------------------

class GetLedgers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.GetLedgers) */ {
 public:
  GetLedgers();
  virtual ~GetLedgers();

  GetLedgers(const GetLedgers& from);

  inline GetLedgers& operator=(const GetLedgers& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLedgers& default_instance();

  void Swap(GetLedgers* other);

  // implements Message ----------------------------------------------

  inline GetLedgers* New() const { return New(NULL); }

  GetLedgers* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLedgers& from);
  void MergeFrom(const GetLedgers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetLedgers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 begin = 1;
  void clear_begin();
  static const int kBeginFieldNumber = 1;
  ::google::protobuf::int64 begin() const;
  void set_begin(::google::protobuf::int64 value);

  // optional int64 end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int64 end() const;
  void set_end(::google::protobuf::int64 value);

  // optional int64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional int64 chain_id = 4;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 4;
  ::google::protobuf::int64 chain_id() const;
  void set_chain_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.GetLedgers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 begin_;
  ::google::protobuf::int64 end_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 chain_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static GetLedgers* default_instance_;
};
// -------------------------------------------------------------------

class Ledgers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Ledgers) */ {
 public:
  Ledgers();
  virtual ~Ledgers();

  Ledgers(const Ledgers& from);

  inline Ledgers& operator=(const Ledgers& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ledgers& default_instance();

  void Swap(Ledgers* other);

  // implements Message ----------------------------------------------

  inline Ledgers* New() const { return New(NULL); }

  Ledgers* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ledgers& from);
  void MergeFrom(const Ledgers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ledgers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Ledgers_SyncCode SyncCode;
  static const SyncCode OK =
    Ledgers_SyncCode_OK;
  static const SyncCode OUT_OF_SYNC =
    Ledgers_SyncCode_OUT_OF_SYNC;
  static const SyncCode OUT_OF_LEDGERS =
    Ledgers_SyncCode_OUT_OF_LEDGERS;
  static const SyncCode BUSY =
    Ledgers_SyncCode_BUSY;
  static const SyncCode REFUSE =
    Ledgers_SyncCode_REFUSE;
  static const SyncCode INTERNAL =
    Ledgers_SyncCode_INTERNAL;
  static inline bool SyncCode_IsValid(int value) {
    return Ledgers_SyncCode_IsValid(value);
  }
  static const SyncCode SyncCode_MIN =
    Ledgers_SyncCode_SyncCode_MIN;
  static const SyncCode SyncCode_MAX =
    Ledgers_SyncCode_SyncCode_MAX;
  static const int SyncCode_ARRAYSIZE =
    Ledgers_SyncCode_SyncCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SyncCode_descriptor() {
    return Ledgers_SyncCode_descriptor();
  }
  static inline const ::std::string& SyncCode_Name(SyncCode value) {
    return Ledgers_SyncCode_Name(value);
  }
  static inline bool SyncCode_Parse(const ::std::string& name,
      SyncCode* value) {
    return Ledgers_SyncCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .protocol.ConsensusValue values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::protocol::ConsensusValue& values(int index) const;
  ::protocol::ConsensusValue* mutable_values(int index);
  ::protocol::ConsensusValue* add_values();
  ::google::protobuf::RepeatedPtrField< ::protocol::ConsensusValue >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::protocol::ConsensusValue >&
      values() const;

  // optional .protocol.Ledgers.SyncCode sync_code = 2;
  void clear_sync_code();
  static const int kSyncCodeFieldNumber = 2;
  ::protocol::Ledgers_SyncCode sync_code() const;
  void set_sync_code(::protocol::Ledgers_SyncCode value);

  // optional int64 max_seq = 3;
  void clear_max_seq();
  static const int kMaxSeqFieldNumber = 3;
  ::google::protobuf::int64 max_seq() const;
  void set_max_seq(::google::protobuf::int64 value);

  // optional bytes proof = 4;
  void clear_proof();
  static const int kProofFieldNumber = 4;
  const ::std::string& proof() const;
  void set_proof(const ::std::string& value);
  void set_proof(const char* value);
  void set_proof(const void* value, size_t size);
  ::std::string* mutable_proof();
  ::std::string* release_proof();
  void set_allocated_proof(::std::string* proof);

  // optional int64 chain_id = 5;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 5;
  ::google::protobuf::int64 chain_id() const;
  void set_chain_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Ledgers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::protocol::ConsensusValue > values_;
  ::google::protobuf::int64 max_seq_;
  ::google::protobuf::internal::ArenaStringPtr proof_;
  ::google::protobuf::int64 chain_id_;
  int sync_code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static Ledgers* default_instance_;
};
// -------------------------------------------------------------------

class DontHave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.DontHave) */ {
 public:
  DontHave();
  virtual ~DontHave();

  DontHave(const DontHave& from);

  inline DontHave& operator=(const DontHave& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DontHave& default_instance();

  void Swap(DontHave* other);

  // implements Message ----------------------------------------------

  inline DontHave* New() const { return New(NULL); }

  DontHave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DontHave& from);
  void MergeFrom(const DontHave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DontHave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int64 type() const;
  void set_type(::google::protobuf::int64 value);

  // optional bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:protocol.DontHave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 type_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static DontHave* default_instance_;
};
// -------------------------------------------------------------------

class LedgerUpgradeNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LedgerUpgradeNotify) */ {
 public:
  LedgerUpgradeNotify();
  virtual ~LedgerUpgradeNotify();

  LedgerUpgradeNotify(const LedgerUpgradeNotify& from);

  inline LedgerUpgradeNotify& operator=(const LedgerUpgradeNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerUpgradeNotify& default_instance();

  void Swap(LedgerUpgradeNotify* other);

  // implements Message ----------------------------------------------

  inline LedgerUpgradeNotify* New() const { return New(NULL); }

  LedgerUpgradeNotify* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LedgerUpgradeNotify& from);
  void MergeFrom(const LedgerUpgradeNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LedgerUpgradeNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 nonce = 1;
  void clear_nonce();
  static const int kNonceFieldNumber = 1;
  ::google::protobuf::int64 nonce() const;
  void set_nonce(::google::protobuf::int64 value);

  // optional .protocol.LedgerUpgrade upgrade = 2;
  bool has_upgrade() const;
  void clear_upgrade();
  static const int kUpgradeFieldNumber = 2;
  const ::protocol::LedgerUpgrade& upgrade() const;
  ::protocol::LedgerUpgrade* mutable_upgrade();
  ::protocol::LedgerUpgrade* release_upgrade();
  void set_allocated_upgrade(::protocol::LedgerUpgrade* upgrade);

  // optional .protocol.Signature signature = 3;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const ::protocol::Signature& signature() const;
  ::protocol::Signature* mutable_signature();
  ::protocol::Signature* release_signature();
  void set_allocated_signature(::protocol::Signature* signature);

  // @@protoc_insertion_point(class_scope:protocol.LedgerUpgradeNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 nonce_;
  ::protocol::LedgerUpgrade* upgrade_;
  ::protocol::Signature* signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static LedgerUpgradeNotify* default_instance_;
};
// -------------------------------------------------------------------

class EntryList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EntryList) */ {
 public:
  EntryList();
  virtual ~EntryList();

  EntryList(const EntryList& from);

  inline EntryList& operator=(const EntryList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntryList& default_instance();

  void Swap(EntryList* other);

  // implements Message ----------------------------------------------

  inline EntryList* New() const { return New(NULL); }

  EntryList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntryList& from);
  void MergeFrom(const EntryList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EntryList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes entry = 1;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 1;
  const ::std::string& entry(int index) const;
  ::std::string* mutable_entry(int index);
  void set_entry(int index, const ::std::string& value);
  void set_entry(int index, const char* value);
  void set_entry(int index, const void* value, size_t size);
  ::std::string* add_entry();
  void add_entry(const ::std::string& value);
  void add_entry(const char* value);
  void add_entry(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& entry() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_entry();

  // @@protoc_insertion_point(class_scope:protocol.EntryList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> entry_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static EntryList* default_instance_;
};
// -------------------------------------------------------------------

class ChainHello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainHello) */ {
 public:
  ChainHello();
  virtual ~ChainHello();

  ChainHello(const ChainHello& from);

  inline ChainHello& operator=(const ChainHello& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainHello& default_instance();

  void Swap(ChainHello* other);

  // implements Message ----------------------------------------------

  inline ChainHello* New() const { return New(NULL); }

  ChainHello* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainHello& from);
  void MergeFrom(const ChainHello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.ChainMessageType api_list = 1;
  int api_list_size() const;
  void clear_api_list();
  static const int kApiListFieldNumber = 1;
  ::protocol::ChainMessageType api_list(int index) const;
  void set_api_list(int index, ::protocol::ChainMessageType value);
  void add_api_list(::protocol::ChainMessageType value);
  const ::google::protobuf::RepeatedField<int>& api_list() const;
  ::google::protobuf::RepeatedField<int>* mutable_api_list();

  // optional int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainHello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField<int> api_list_;
  mutable int _api_list_cached_byte_size_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static ChainHello* default_instance_;
};
// -------------------------------------------------------------------

class ChainStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainStatus) */ {
 public:
  ChainStatus();
  virtual ~ChainStatus();

  ChainStatus(const ChainStatus& from);

  inline ChainStatus& operator=(const ChainStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainStatus& default_instance();

  void Swap(ChainStatus* other);

  // implements Message ----------------------------------------------

  inline ChainStatus* New() const { return New(NULL); }

  ChainStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainStatus& from);
  void MergeFrom(const ChainStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string self_addr = 1;
  void clear_self_addr();
  static const int kSelfAddrFieldNumber = 1;
  const ::std::string& self_addr() const;
  void set_self_addr(const ::std::string& value);
  void set_self_addr(const char* value);
  void set_self_addr(const char* value, size_t size);
  ::std::string* mutable_self_addr();
  ::std::string* release_self_addr();
  void set_allocated_self_addr(::std::string* self_addr);

  // optional int64 ledger_version = 2;
  void clear_ledger_version();
  static const int kLedgerVersionFieldNumber = 2;
  ::google::protobuf::int64 ledger_version() const;
  void set_ledger_version(::google::protobuf::int64 value);

  // optional int64 monitor_version = 3;
  void clear_monitor_version();
  static const int kMonitorVersionFieldNumber = 3;
  ::google::protobuf::int64 monitor_version() const;
  void set_monitor_version(::google::protobuf::int64 value);

  // optional string CEG_version = 4;
  void clear_CEG_version();
  static const int kCEGVersionFieldNumber = 4;
  const ::std::string& CEG_version() const;
  void set_CEG_version(const ::std::string& value);
  void set_CEG_version(const char* value);
  void set_CEG_version(const char* value, size_t size);
  ::std::string* mutable_CEG_version();
  ::std::string* release_CEG_version();
  void set_allocated_CEG_version(::std::string* CEG_version);

  // optional int64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr self_addr_;
  ::google::protobuf::int64 ledger_version_;
  ::google::protobuf::int64 monitor_version_;
  ::google::protobuf::internal::ArenaStringPtr CEG_version_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static ChainStatus* default_instance_;
};
// -------------------------------------------------------------------

class ChainPeerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainPeerMessage) */ {
 public:
  ChainPeerMessage();
  virtual ~ChainPeerMessage();

  ChainPeerMessage(const ChainPeerMessage& from);

  inline ChainPeerMessage& operator=(const ChainPeerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainPeerMessage& default_instance();

  void Swap(ChainPeerMessage* other);

  // implements Message ----------------------------------------------

  inline ChainPeerMessage* New() const { return New(NULL); }

  ChainPeerMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainPeerMessage& from);
  void MergeFrom(const ChainPeerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainPeerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string src_peer_addr = 1;
  void clear_src_peer_addr();
  static const int kSrcPeerAddrFieldNumber = 1;
  const ::std::string& src_peer_addr() const;
  void set_src_peer_addr(const ::std::string& value);
  void set_src_peer_addr(const char* value);
  void set_src_peer_addr(const char* value, size_t size);
  ::std::string* mutable_src_peer_addr();
  ::std::string* release_src_peer_addr();
  void set_allocated_src_peer_addr(::std::string* src_peer_addr);

  // repeated string des_peer_addrs = 2;
  int des_peer_addrs_size() const;
  void clear_des_peer_addrs();
  static const int kDesPeerAddrsFieldNumber = 2;
  const ::std::string& des_peer_addrs(int index) const;
  ::std::string* mutable_des_peer_addrs(int index);
  void set_des_peer_addrs(int index, const ::std::string& value);
  void set_des_peer_addrs(int index, const char* value);
  void set_des_peer_addrs(int index, const char* value, size_t size);
  ::std::string* add_des_peer_addrs();
  void add_des_peer_addrs(const ::std::string& value);
  void add_des_peer_addrs(const char* value);
  void add_des_peer_addrs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& des_peer_addrs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_des_peer_addrs();

  // optional bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:protocol.ChainPeerMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr src_peer_addr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> des_peer_addrs_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static ChainPeerMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChainSubscribeTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainSubscribeTx) */ {
 public:
  ChainSubscribeTx();
  virtual ~ChainSubscribeTx();

  ChainSubscribeTx(const ChainSubscribeTx& from);

  inline ChainSubscribeTx& operator=(const ChainSubscribeTx& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainSubscribeTx& default_instance();

  void Swap(ChainSubscribeTx* other);

  // implements Message ----------------------------------------------

  inline ChainSubscribeTx* New() const { return New(NULL); }

  ChainSubscribeTx* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainSubscribeTx& from);
  void MergeFrom(const ChainSubscribeTx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainSubscribeTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string address = 1;
  int address_size() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address(int index) const;
  ::std::string* mutable_address(int index);
  void set_address(int index, const ::std::string& value);
  void set_address(int index, const char* value);
  void set_address(int index, const char* value, size_t size);
  ::std::string* add_address();
  void add_address(const ::std::string& value);
  void add_address(const char* value);
  void add_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_address();

  // @@protoc_insertion_point(class_scope:protocol.ChainSubscribeTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> address_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static ChainSubscribeTx* default_instance_;
};
// -------------------------------------------------------------------

class ChainResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainResponse) */ {
 public:
  ChainResponse();
  virtual ~ChainResponse();

  ChainResponse(const ChainResponse& from);

  inline ChainResponse& operator=(const ChainResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainResponse& default_instance();

  void Swap(ChainResponse* other);

  // implements Message ----------------------------------------------

  inline ChainResponse* New() const { return New(NULL); }

  ChainResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainResponse& from);
  void MergeFrom(const ChainResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // optional string error_desc = 2;
  void clear_error_desc();
  static const int kErrorDescFieldNumber = 2;
  const ::std::string& error_desc() const;
  void set_error_desc(const ::std::string& value);
  void set_error_desc(const char* value);
  void set_error_desc(const char* value, size_t size);
  ::std::string* mutable_error_desc();
  ::std::string* release_error_desc();
  void set_allocated_error_desc(::std::string* error_desc);

  // @@protoc_insertion_point(class_scope:protocol.ChainResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr error_desc_;
  ::google::protobuf::int32 error_code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static ChainResponse* default_instance_;
};
// -------------------------------------------------------------------

class ChainTxStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainTxStatus) */ {
 public:
  ChainTxStatus();
  virtual ~ChainTxStatus();

  ChainTxStatus(const ChainTxStatus& from);

  inline ChainTxStatus& operator=(const ChainTxStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainTxStatus& default_instance();

  void Swap(ChainTxStatus* other);

  // implements Message ----------------------------------------------

  inline ChainTxStatus* New() const { return New(NULL); }

  ChainTxStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainTxStatus& from);
  void MergeFrom(const ChainTxStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainTxStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChainTxStatus_TxStatus TxStatus;
  static const TxStatus UNDEFINED =
    ChainTxStatus_TxStatus_UNDEFINED;
  static const TxStatus CONFIRMED =
    ChainTxStatus_TxStatus_CONFIRMED;
  static const TxStatus PENDING =
    ChainTxStatus_TxStatus_PENDING;
  static const TxStatus COMPLETE =
    ChainTxStatus_TxStatus_COMPLETE;
  static const TxStatus FAILURE =
    ChainTxStatus_TxStatus_FAILURE;
  static inline bool TxStatus_IsValid(int value) {
    return ChainTxStatus_TxStatus_IsValid(value);
  }
  static const TxStatus TxStatus_MIN =
    ChainTxStatus_TxStatus_TxStatus_MIN;
  static const TxStatus TxStatus_MAX =
    ChainTxStatus_TxStatus_TxStatus_MAX;
  static const int TxStatus_ARRAYSIZE =
    ChainTxStatus_TxStatus_TxStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TxStatus_descriptor() {
    return ChainTxStatus_TxStatus_descriptor();
  }
  static inline const ::std::string& TxStatus_Name(TxStatus value) {
    return ChainTxStatus_TxStatus_Name(value);
  }
  static inline bool TxStatus_Parse(const ::std::string& name,
      TxStatus* value) {
    return ChainTxStatus_TxStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protocol.ChainTxStatus.TxStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::protocol::ChainTxStatus_TxStatus status() const;
  void set_status(::protocol::ChainTxStatus_TxStatus value);

  // optional string tx_hash = 2;
  void clear_tx_hash();
  static const int kTxHashFieldNumber = 2;
  const ::std::string& tx_hash() const;
  void set_tx_hash(const ::std::string& value);
  void set_tx_hash(const char* value);
  void set_tx_hash(const char* value, size_t size);
  ::std::string* mutable_tx_hash();
  ::std::string* release_tx_hash();
  void set_allocated_tx_hash(::std::string* tx_hash);

  // optional string source_address = 3;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 3;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // optional int64 source_account_seq = 4;
  void clear_source_account_seq();
  static const int kSourceAccountSeqFieldNumber = 4;
  ::google::protobuf::int64 source_account_seq() const;
  void set_source_account_seq(::google::protobuf::int64 value);

  // optional int64 ledger_seq = 5;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 5;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // optional int64 new_account_seq = 6;
  void clear_new_account_seq();
  static const int kNewAccountSeqFieldNumber = 6;
  ::google::protobuf::int64 new_account_seq() const;
  void set_new_account_seq(::google::protobuf::int64 value);

  // optional .protocol.ERRORCODE error_code = 7;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 7;
  ::protocol::ERRORCODE error_code() const;
  void set_error_code(::protocol::ERRORCODE value);

  // optional string error_desc = 8;
  void clear_error_desc();
  static const int kErrorDescFieldNumber = 8;
  const ::std::string& error_desc() const;
  void set_error_desc(const ::std::string& value);
  void set_error_desc(const char* value);
  void set_error_desc(const char* value, size_t size);
  ::std::string* mutable_error_desc();
  ::std::string* release_error_desc();
  void set_allocated_error_desc(::std::string* error_desc);

  // optional int64 timestamp = 9;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainTxStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr tx_hash_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::int64 source_account_seq_;
  int status_;
  int error_code_;
  ::google::protobuf::int64 ledger_seq_;
  ::google::protobuf::int64 new_account_seq_;
  ::google::protobuf::internal::ArenaStringPtr error_desc_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static ChainTxStatus* default_instance_;
};
// -------------------------------------------------------------------

class ChainInfoMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainInfoMessage) */ {
 public:
  ChainInfoMessage();
  virtual ~ChainInfoMessage();

  ChainInfoMessage(const ChainInfoMessage& from);

  inline ChainInfoMessage& operator=(const ChainInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainInfoMessage& default_instance();

  void Swap(ChainInfoMessage* other);

  // implements Message ----------------------------------------------

  inline ChainInfoMessage* New() const { return New(NULL); }

  ChainInfoMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChainInfoMessage& from);
  void MergeFrom(const ChainInfoMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChainInfoMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 seq = 1;
  void clear_seq();
  static const int kSeqFieldNumber = 1;
  ::google::protobuf::int64 seq() const;
  void set_seq(::google::protobuf::int64 value);

  // optional string address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:protocol.ChainInfoMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 seq_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_overlay_2eproto();
  friend void protobuf_AssignDesc_overlay_2eproto();
  friend void protobuf_ShutdownFile_overlay_2eproto();

  void InitAsDefaultInstance();
  static ChainInfoMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Hello

// optional int64 network_id = 1;
inline void Hello::clear_network_id() {
  network_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::network_id() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.network_id)
  return network_id_;
}
inline void Hello::set_network_id(::google::protobuf::int64 value) {
  
  network_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Hello.network_id)
}

// optional int64 ledger_version = 2;
inline void Hello::clear_ledger_version() {
  ledger_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.ledger_version)
  return ledger_version_;
}
inline void Hello::set_ledger_version(::google::protobuf::int64 value) {
  
  ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.Hello.ledger_version)
}

// optional int64 overlay_version = 3;
inline void Hello::clear_overlay_version() {
  overlay_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::overlay_version() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.overlay_version)
  return overlay_version_;
}
inline void Hello::set_overlay_version(::google::protobuf::int64 value) {
  
  overlay_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.Hello.overlay_version)
}

// optional string CEG_version = 4;
inline void Hello::clear_CEG_version() {
  CEG_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hello::CEG_version() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.CEG_version)
  return CEG_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_CEG_version(const ::std::string& value) {
  
  CEG_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Hello.CEG_version)
}
inline void Hello::set_CEG_version(const char* value) {
  
  CEG_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Hello.CEG_version)
}
inline void Hello::set_CEG_version(const char* value, size_t size) {
  
  CEG_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Hello.CEG_version)
}
inline ::std::string* Hello::mutable_CEG_version() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Hello.CEG_version)
  return CEG_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_CEG_version() {
  // @@protoc_insertion_point(field_release:protocol.Hello.CEG_version)
  
  return CEG_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_CEG_version(::std::string* CEG_version) {
  if (CEG_version != NULL) {
    
  } else {
    
  }
  CEG_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), CEG_version);
  // @@protoc_insertion_point(field_set_allocated:protocol.Hello.CEG_version)
}

// optional int64 listening_port = 5;
inline void Hello::clear_listening_port() {
  listening_port_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Hello::listening_port() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.listening_port)
  return listening_port_;
}
inline void Hello::set_listening_port(::google::protobuf::int64 value) {
  
  listening_port_ = value;
  // @@protoc_insertion_point(field_set:protocol.Hello.listening_port)
}

// optional string node_address = 6;
inline void Hello::clear_node_address() {
  node_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hello::node_address() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.node_address)
  return node_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_node_address(const ::std::string& value) {
  
  node_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Hello.node_address)
}
inline void Hello::set_node_address(const char* value) {
  
  node_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Hello.node_address)
}
inline void Hello::set_node_address(const char* value, size_t size) {
  
  node_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Hello.node_address)
}
inline ::std::string* Hello::mutable_node_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Hello.node_address)
  return node_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_node_address() {
  // @@protoc_insertion_point(field_release:protocol.Hello.node_address)
  
  return node_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_node_address(::std::string* node_address) {
  if (node_address != NULL) {
    
  } else {
    
  }
  node_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Hello.node_address)
}

// optional string node_rand = 7;
inline void Hello::clear_node_rand() {
  node_rand_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hello::node_rand() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.node_rand)
  return node_rand_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_node_rand(const ::std::string& value) {
  
  node_rand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Hello.node_rand)
}
inline void Hello::set_node_rand(const char* value) {
  
  node_rand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Hello.node_rand)
}
inline void Hello::set_node_rand(const char* value, size_t size) {
  
  node_rand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Hello.node_rand)
}
inline ::std::string* Hello::mutable_node_rand() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Hello.node_rand)
  return node_rand_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_node_rand() {
  // @@protoc_insertion_point(field_release:protocol.Hello.node_rand)
  
  return node_rand_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_node_rand(::std::string* node_rand) {
  if (node_rand != NULL) {
    
  } else {
    
  }
  node_rand_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_rand);
  // @@protoc_insertion_point(field_set_allocated:protocol.Hello.node_rand)
}

// -------------------------------------------------------------------

// HelloResponse

// optional .protocol.ERRORCODE error_code = 1;
inline void HelloResponse::clear_error_code() {
  error_code_ = 0;
}
inline ::protocol::ERRORCODE HelloResponse::error_code() const {
  // @@protoc_insertion_point(field_get:protocol.HelloResponse.error_code)
  return static_cast< ::protocol::ERRORCODE >(error_code_);
}
inline void HelloResponse::set_error_code(::protocol::ERRORCODE value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.HelloResponse.error_code)
}

// optional string error_desc = 2;
inline void HelloResponse::clear_error_desc() {
  error_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloResponse::error_desc() const {
  // @@protoc_insertion_point(field_get:protocol.HelloResponse.error_desc)
  return error_desc_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloResponse::set_error_desc(const ::std::string& value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.HelloResponse.error_desc)
}
inline void HelloResponse::set_error_desc(const char* value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.HelloResponse.error_desc)
}
inline void HelloResponse::set_error_desc(const char* value, size_t size) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.HelloResponse.error_desc)
}
inline ::std::string* HelloResponse::mutable_error_desc() {
  
  // @@protoc_insertion_point(field_mutable:protocol.HelloResponse.error_desc)
  return error_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloResponse::release_error_desc() {
  // @@protoc_insertion_point(field_release:protocol.HelloResponse.error_desc)
  
  return error_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloResponse::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc != NULL) {
    
  } else {
    
  }
  error_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_desc);
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloResponse.error_desc)
}

// -------------------------------------------------------------------

// Peer

// optional string ip = 1;
inline void Peer::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Peer::ip() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.ip)
  return ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Peer.ip)
}
inline void Peer::set_ip(const char* value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Peer.ip)
}
inline void Peer::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Peer.ip)
}
inline ::std::string* Peer::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Peer.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_ip() {
  // @@protoc_insertion_point(field_release:protocol.Peer.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:protocol.Peer.ip)
}

// optional int64 port = 2;
inline void Peer::clear_port() {
  port_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Peer::port() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.port)
  return port_;
}
inline void Peer::set_port(::google::protobuf::int64 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:protocol.Peer.port)
}

// optional int64 num_failures = 3;
inline void Peer::clear_num_failures() {
  num_failures_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Peer::num_failures() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.num_failures)
  return num_failures_;
}
inline void Peer::set_num_failures(::google::protobuf::int64 value) {
  
  num_failures_ = value;
  // @@protoc_insertion_point(field_set:protocol.Peer.num_failures)
}

// optional int64 next_attempt_time = 4;
inline void Peer::clear_next_attempt_time() {
  next_attempt_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Peer::next_attempt_time() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.next_attempt_time)
  return next_attempt_time_;
}
inline void Peer::set_next_attempt_time(::google::protobuf::int64 value) {
  
  next_attempt_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Peer.next_attempt_time)
}

// optional int64 active_time = 5;
inline void Peer::clear_active_time() {
  active_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Peer::active_time() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.active_time)
  return active_time_;
}
inline void Peer::set_active_time(::google::protobuf::int64 value) {
  
  active_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Peer.active_time)
}

// optional int64 connection_id = 6;
inline void Peer::clear_connection_id() {
  connection_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Peer::connection_id() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.connection_id)
  return connection_id_;
}
inline void Peer::set_connection_id(::google::protobuf::int64 value) {
  
  connection_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Peer.connection_id)
}

// -------------------------------------------------------------------

// Peers

// repeated .protocol.Peer peers = 1;
inline int Peers::peers_size() const {
  return peers_.size();
}
inline void Peers::clear_peers() {
  peers_.Clear();
}
inline const ::protocol::Peer& Peers::peers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Peers.peers)
  return peers_.Get(index);
}
inline ::protocol::Peer* Peers::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Peers.peers)
  return peers_.Mutable(index);
}
inline ::protocol::Peer* Peers::add_peers() {
  // @@protoc_insertion_point(field_add:protocol.Peers.peers)
  return peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Peer >*
Peers::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Peers.peers)
  return &peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Peer >&
Peers::peers() const {
  // @@protoc_insertion_point(field_list:protocol.Peers.peers)
  return peers_;
}

// -------------------------------------------------------------------

// GetLedgers

// optional int64 begin = 1;
inline void GetLedgers::clear_begin() {
  begin_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetLedgers::begin() const {
  // @@protoc_insertion_point(field_get:protocol.GetLedgers.begin)
  return begin_;
}
inline void GetLedgers::set_begin(::google::protobuf::int64 value) {
  
  begin_ = value;
  // @@protoc_insertion_point(field_set:protocol.GetLedgers.begin)
}

// optional int64 end = 2;
inline void GetLedgers::clear_end() {
  end_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetLedgers::end() const {
  // @@protoc_insertion_point(field_get:protocol.GetLedgers.end)
  return end_;
}
inline void GetLedgers::set_end(::google::protobuf::int64 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:protocol.GetLedgers.end)
}

// optional int64 timestamp = 3;
inline void GetLedgers::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetLedgers::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.GetLedgers.timestamp)
  return timestamp_;
}
inline void GetLedgers::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.GetLedgers.timestamp)
}

// optional int64 chain_id = 4;
inline void GetLedgers::clear_chain_id() {
  chain_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetLedgers::chain_id() const {
  // @@protoc_insertion_point(field_get:protocol.GetLedgers.chain_id)
  return chain_id_;
}
inline void GetLedgers::set_chain_id(::google::protobuf::int64 value) {
  
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.GetLedgers.chain_id)
}

// -------------------------------------------------------------------

// Ledgers

// repeated .protocol.ConsensusValue values = 1;
inline int Ledgers::values_size() const {
  return values_.size();
}
inline void Ledgers::clear_values() {
  values_.Clear();
}
inline const ::protocol::ConsensusValue& Ledgers::values(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.values)
  return values_.Get(index);
}
inline ::protocol::ConsensusValue* Ledgers::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Ledgers.values)
  return values_.Mutable(index);
}
inline ::protocol::ConsensusValue* Ledgers::add_values() {
  // @@protoc_insertion_point(field_add:protocol.Ledgers.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::ConsensusValue >*
Ledgers::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Ledgers.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::ConsensusValue >&
Ledgers::values() const {
  // @@protoc_insertion_point(field_list:protocol.Ledgers.values)
  return values_;
}

// optional .protocol.Ledgers.SyncCode sync_code = 2;
inline void Ledgers::clear_sync_code() {
  sync_code_ = 0;
}
inline ::protocol::Ledgers_SyncCode Ledgers::sync_code() const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.sync_code)
  return static_cast< ::protocol::Ledgers_SyncCode >(sync_code_);
}
inline void Ledgers::set_sync_code(::protocol::Ledgers_SyncCode value) {
  
  sync_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.Ledgers.sync_code)
}

// optional int64 max_seq = 3;
inline void Ledgers::clear_max_seq() {
  max_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Ledgers::max_seq() const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.max_seq)
  return max_seq_;
}
inline void Ledgers::set_max_seq(::google::protobuf::int64 value) {
  
  max_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.Ledgers.max_seq)
}

// optional bytes proof = 4;
inline void Ledgers::clear_proof() {
  proof_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Ledgers::proof() const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.proof)
  return proof_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ledgers::set_proof(const ::std::string& value) {
  
  proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Ledgers.proof)
}
inline void Ledgers::set_proof(const char* value) {
  
  proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Ledgers.proof)
}
inline void Ledgers::set_proof(const void* value, size_t size) {
  
  proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Ledgers.proof)
}
inline ::std::string* Ledgers::mutable_proof() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Ledgers.proof)
  return proof_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ledgers::release_proof() {
  // @@protoc_insertion_point(field_release:protocol.Ledgers.proof)
  
  return proof_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ledgers::set_allocated_proof(::std::string* proof) {
  if (proof != NULL) {
    
  } else {
    
  }
  proof_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proof);
  // @@protoc_insertion_point(field_set_allocated:protocol.Ledgers.proof)
}

// optional int64 chain_id = 5;
inline void Ledgers::clear_chain_id() {
  chain_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Ledgers::chain_id() const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.chain_id)
  return chain_id_;
}
inline void Ledgers::set_chain_id(::google::protobuf::int64 value) {
  
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Ledgers.chain_id)
}

// -------------------------------------------------------------------

// DontHave

// optional int64 type = 1;
inline void DontHave::clear_type() {
  type_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DontHave::type() const {
  // @@protoc_insertion_point(field_get:protocol.DontHave.type)
  return type_;
}
inline void DontHave::set_type(::google::protobuf::int64 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.DontHave.type)
}

// optional bytes hash = 2;
inline void DontHave::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DontHave::hash() const {
  // @@protoc_insertion_point(field_get:protocol.DontHave.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DontHave::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.DontHave.hash)
}
inline void DontHave::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.DontHave.hash)
}
inline void DontHave::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.DontHave.hash)
}
inline ::std::string* DontHave::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.DontHave.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DontHave::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.DontHave.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DontHave::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.DontHave.hash)
}

// -------------------------------------------------------------------

// LedgerUpgradeNotify

// optional int64 nonce = 1;
inline void LedgerUpgradeNotify::clear_nonce() {
  nonce_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerUpgradeNotify::nonce() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerUpgradeNotify.nonce)
  return nonce_;
}
inline void LedgerUpgradeNotify::set_nonce(::google::protobuf::int64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerUpgradeNotify.nonce)
}

// optional .protocol.LedgerUpgrade upgrade = 2;
inline bool LedgerUpgradeNotify::has_upgrade() const {
  return !_is_default_instance_ && upgrade_ != NULL;
}
inline void LedgerUpgradeNotify::clear_upgrade() {
  if (GetArenaNoVirtual() == NULL && upgrade_ != NULL) delete upgrade_;
  upgrade_ = NULL;
}
inline const ::protocol::LedgerUpgrade& LedgerUpgradeNotify::upgrade() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerUpgradeNotify.upgrade)
  return upgrade_ != NULL ? *upgrade_ : *default_instance_->upgrade_;
}
inline ::protocol::LedgerUpgrade* LedgerUpgradeNotify::mutable_upgrade() {
  
  if (upgrade_ == NULL) {
    upgrade_ = new ::protocol::LedgerUpgrade;
  }
  // @@protoc_insertion_point(field_mutable:protocol.LedgerUpgradeNotify.upgrade)
  return upgrade_;
}
inline ::protocol::LedgerUpgrade* LedgerUpgradeNotify::release_upgrade() {
  // @@protoc_insertion_point(field_release:protocol.LedgerUpgradeNotify.upgrade)
  
  ::protocol::LedgerUpgrade* temp = upgrade_;
  upgrade_ = NULL;
  return temp;
}
inline void LedgerUpgradeNotify::set_allocated_upgrade(::protocol::LedgerUpgrade* upgrade) {
  delete upgrade_;
  upgrade_ = upgrade;
  if (upgrade) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerUpgradeNotify.upgrade)
}

// optional .protocol.Signature signature = 3;
inline bool LedgerUpgradeNotify::has_signature() const {
  return !_is_default_instance_ && signature_ != NULL;
}
inline void LedgerUpgradeNotify::clear_signature() {
  if (GetArenaNoVirtual() == NULL && signature_ != NULL) delete signature_;
  signature_ = NULL;
}
inline const ::protocol::Signature& LedgerUpgradeNotify::signature() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerUpgradeNotify.signature)
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::protocol::Signature* LedgerUpgradeNotify::mutable_signature() {
  
  if (signature_ == NULL) {
    signature_ = new ::protocol::Signature;
  }
  // @@protoc_insertion_point(field_mutable:protocol.LedgerUpgradeNotify.signature)
  return signature_;
}
inline ::protocol::Signature* LedgerUpgradeNotify::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.LedgerUpgradeNotify.signature)
  
  ::protocol::Signature* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void LedgerUpgradeNotify::set_allocated_signature(::protocol::Signature* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerUpgradeNotify.signature)
}

// -------------------------------------------------------------------

// EntryList

// repeated bytes entry = 1;
inline int EntryList::entry_size() const {
  return entry_.size();
}
inline void EntryList::clear_entry() {
  entry_.Clear();
}
inline const ::std::string& EntryList::entry(int index) const {
  // @@protoc_insertion_point(field_get:protocol.EntryList.entry)
  return entry_.Get(index);
}
inline ::std::string* EntryList::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.EntryList.entry)
  return entry_.Mutable(index);
}
inline void EntryList::set_entry(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.EntryList.entry)
  entry_.Mutable(index)->assign(value);
}
inline void EntryList::set_entry(int index, const char* value) {
  entry_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.EntryList.entry)
}
inline void EntryList::set_entry(int index, const void* value, size_t size) {
  entry_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.EntryList.entry)
}
inline ::std::string* EntryList::add_entry() {
  // @@protoc_insertion_point(field_add_mutable:protocol.EntryList.entry)
  return entry_.Add();
}
inline void EntryList::add_entry(const ::std::string& value) {
  entry_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.EntryList.entry)
}
inline void EntryList::add_entry(const char* value) {
  entry_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.EntryList.entry)
}
inline void EntryList::add_entry(const void* value, size_t size) {
  entry_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.EntryList.entry)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EntryList::entry() const {
  // @@protoc_insertion_point(field_list:protocol.EntryList.entry)
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EntryList::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:protocol.EntryList.entry)
  return &entry_;
}

// -------------------------------------------------------------------

// ChainHello

// repeated .protocol.ChainMessageType api_list = 1;
inline int ChainHello::api_list_size() const {
  return api_list_.size();
}
inline void ChainHello::clear_api_list() {
  api_list_.Clear();
}
inline ::protocol::ChainMessageType ChainHello::api_list(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainHello.api_list)
  return static_cast< ::protocol::ChainMessageType >(api_list_.Get(index));
}
inline void ChainHello::set_api_list(int index, ::protocol::ChainMessageType value) {
  api_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.ChainHello.api_list)
}
inline void ChainHello::add_api_list(::protocol::ChainMessageType value) {
  api_list_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.ChainHello.api_list)
}
inline const ::google::protobuf::RepeatedField<int>&
ChainHello::api_list() const {
  // @@protoc_insertion_point(field_list:protocol.ChainHello.api_list)
  return api_list_;
}
inline ::google::protobuf::RepeatedField<int>*
ChainHello::mutable_api_list() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainHello.api_list)
  return &api_list_;
}

// optional int64 timestamp = 2;
inline void ChainHello::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainHello::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainHello.timestamp)
  return timestamp_;
}
inline void ChainHello::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainHello.timestamp)
}

// -------------------------------------------------------------------

// ChainStatus

// optional string self_addr = 1;
inline void ChainStatus::clear_self_addr() {
  self_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainStatus::self_addr() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.self_addr)
  return self_addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainStatus::set_self_addr(const ::std::string& value) {
  
  self_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.self_addr)
}
inline void ChainStatus::set_self_addr(const char* value) {
  
  self_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainStatus.self_addr)
}
inline void ChainStatus::set_self_addr(const char* value, size_t size) {
  
  self_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainStatus.self_addr)
}
inline ::std::string* ChainStatus::mutable_self_addr() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainStatus.self_addr)
  return self_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainStatus::release_self_addr() {
  // @@protoc_insertion_point(field_release:protocol.ChainStatus.self_addr)
  
  return self_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainStatus::set_allocated_self_addr(::std::string* self_addr) {
  if (self_addr != NULL) {
    
  } else {
    
  }
  self_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), self_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainStatus.self_addr)
}

// optional int64 ledger_version = 2;
inline void ChainStatus::clear_ledger_version() {
  ledger_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainStatus::ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.ledger_version)
  return ledger_version_;
}
inline void ChainStatus::set_ledger_version(::google::protobuf::int64 value) {
  
  ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.ledger_version)
}

// optional int64 monitor_version = 3;
inline void ChainStatus::clear_monitor_version() {
  monitor_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainStatus::monitor_version() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.monitor_version)
  return monitor_version_;
}
inline void ChainStatus::set_monitor_version(::google::protobuf::int64 value) {
  
  monitor_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.monitor_version)
}

// optional string CEG_version = 4;
inline void ChainStatus::clear_CEG_version() {
  CEG_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainStatus::CEG_version() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.CEG_version)
  return CEG_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainStatus::set_CEG_version(const ::std::string& value) {
  
  CEG_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.CEG_version)
}
inline void ChainStatus::set_CEG_version(const char* value) {
  
  CEG_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainStatus.CEG_version)
}
inline void ChainStatus::set_CEG_version(const char* value, size_t size) {
  
  CEG_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainStatus.CEG_version)
}
inline ::std::string* ChainStatus::mutable_CEG_version() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainStatus.CEG_version)
  return CEG_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainStatus::release_CEG_version() {
  // @@protoc_insertion_point(field_release:protocol.ChainStatus.CEG_version)
  
  return CEG_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainStatus::set_allocated_CEG_version(::std::string* CEG_version) {
  if (CEG_version != NULL) {
    
  } else {
    
  }
  CEG_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), CEG_version);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainStatus.CEG_version)
}

// optional int64 timestamp = 5;
inline void ChainStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.timestamp)
  return timestamp_;
}
inline void ChainStatus::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.timestamp)
}

// -------------------------------------------------------------------

// ChainPeerMessage

// optional string src_peer_addr = 1;
inline void ChainPeerMessage::clear_src_peer_addr() {
  src_peer_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainPeerMessage::src_peer_addr() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerMessage.src_peer_addr)
  return src_peer_addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerMessage::set_src_peer_addr(const ::std::string& value) {
  
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainPeerMessage.src_peer_addr)
}
inline void ChainPeerMessage::set_src_peer_addr(const char* value) {
  
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerMessage.src_peer_addr)
}
inline void ChainPeerMessage::set_src_peer_addr(const char* value, size_t size) {
  
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerMessage.src_peer_addr)
}
inline ::std::string* ChainPeerMessage::mutable_src_peer_addr() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerMessage.src_peer_addr)
  return src_peer_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainPeerMessage::release_src_peer_addr() {
  // @@protoc_insertion_point(field_release:protocol.ChainPeerMessage.src_peer_addr)
  
  return src_peer_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerMessage::set_allocated_src_peer_addr(::std::string* src_peer_addr) {
  if (src_peer_addr != NULL) {
    
  } else {
    
  }
  src_peer_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_peer_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainPeerMessage.src_peer_addr)
}

// repeated string des_peer_addrs = 2;
inline int ChainPeerMessage::des_peer_addrs_size() const {
  return des_peer_addrs_.size();
}
inline void ChainPeerMessage::clear_des_peer_addrs() {
  des_peer_addrs_.Clear();
}
inline const ::std::string& ChainPeerMessage::des_peer_addrs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_.Get(index);
}
inline ::std::string* ChainPeerMessage::mutable_des_peer_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_.Mutable(index);
}
inline void ChainPeerMessage::set_des_peer_addrs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.ChainPeerMessage.des_peer_addrs)
  des_peer_addrs_.Mutable(index)->assign(value);
}
inline void ChainPeerMessage::set_des_peer_addrs(int index, const char* value) {
  des_peer_addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerMessage.des_peer_addrs)
}
inline void ChainPeerMessage::set_des_peer_addrs(int index, const char* value, size_t size) {
  des_peer_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerMessage.des_peer_addrs)
}
inline ::std::string* ChainPeerMessage::add_des_peer_addrs() {
  // @@protoc_insertion_point(field_add_mutable:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_.Add();
}
inline void ChainPeerMessage::add_des_peer_addrs(const ::std::string& value) {
  des_peer_addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.ChainPeerMessage.des_peer_addrs)
}
inline void ChainPeerMessage::add_des_peer_addrs(const char* value) {
  des_peer_addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.ChainPeerMessage.des_peer_addrs)
}
inline void ChainPeerMessage::add_des_peer_addrs(const char* value, size_t size) {
  des_peer_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.ChainPeerMessage.des_peer_addrs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChainPeerMessage::des_peer_addrs() const {
  // @@protoc_insertion_point(field_list:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChainPeerMessage::mutable_des_peer_addrs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainPeerMessage.des_peer_addrs)
  return &des_peer_addrs_;
}

// optional bytes data = 3;
inline void ChainPeerMessage::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainPeerMessage::data() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerMessage.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerMessage::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainPeerMessage.data)
}
inline void ChainPeerMessage::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerMessage.data)
}
inline void ChainPeerMessage::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerMessage.data)
}
inline ::std::string* ChainPeerMessage::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerMessage.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainPeerMessage::release_data() {
  // @@protoc_insertion_point(field_release:protocol.ChainPeerMessage.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerMessage::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainPeerMessage.data)
}

// -------------------------------------------------------------------

// ChainSubscribeTx

// repeated string address = 1;
inline int ChainSubscribeTx::address_size() const {
  return address_.size();
}
inline void ChainSubscribeTx::clear_address() {
  address_.Clear();
}
inline const ::std::string& ChainSubscribeTx::address(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainSubscribeTx.address)
  return address_.Get(index);
}
inline ::std::string* ChainSubscribeTx::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ChainSubscribeTx.address)
  return address_.Mutable(index);
}
inline void ChainSubscribeTx::set_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.ChainSubscribeTx.address)
  address_.Mutable(index)->assign(value);
}
inline void ChainSubscribeTx::set_address(int index, const char* value) {
  address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.ChainSubscribeTx.address)
}
inline void ChainSubscribeTx::set_address(int index, const char* value, size_t size) {
  address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainSubscribeTx.address)
}
inline ::std::string* ChainSubscribeTx::add_address() {
  // @@protoc_insertion_point(field_add_mutable:protocol.ChainSubscribeTx.address)
  return address_.Add();
}
inline void ChainSubscribeTx::add_address(const ::std::string& value) {
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.ChainSubscribeTx.address)
}
inline void ChainSubscribeTx::add_address(const char* value) {
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.ChainSubscribeTx.address)
}
inline void ChainSubscribeTx::add_address(const char* value, size_t size) {
  address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.ChainSubscribeTx.address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChainSubscribeTx::address() const {
  // @@protoc_insertion_point(field_list:protocol.ChainSubscribeTx.address)
  return address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChainSubscribeTx::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainSubscribeTx.address)
  return &address_;
}

// -------------------------------------------------------------------

// ChainResponse

// optional int32 error_code = 1;
inline void ChainResponse::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 ChainResponse::error_code() const {
  // @@protoc_insertion_point(field_get:protocol.ChainResponse.error_code)
  return error_code_;
}
inline void ChainResponse::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainResponse.error_code)
}

// optional string error_desc = 2;
inline void ChainResponse::clear_error_desc() {
  error_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainResponse::error_desc() const {
  // @@protoc_insertion_point(field_get:protocol.ChainResponse.error_desc)
  return error_desc_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainResponse::set_error_desc(const ::std::string& value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainResponse.error_desc)
}
inline void ChainResponse::set_error_desc(const char* value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainResponse.error_desc)
}
inline void ChainResponse::set_error_desc(const char* value, size_t size) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainResponse.error_desc)
}
inline ::std::string* ChainResponse::mutable_error_desc() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainResponse.error_desc)
  return error_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainResponse::release_error_desc() {
  // @@protoc_insertion_point(field_release:protocol.ChainResponse.error_desc)
  
  return error_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainResponse::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc != NULL) {
    
  } else {
    
  }
  error_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_desc);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainResponse.error_desc)
}

// -------------------------------------------------------------------

// ChainTxStatus

// optional .protocol.ChainTxStatus.TxStatus status = 1;
inline void ChainTxStatus::clear_status() {
  status_ = 0;
}
inline ::protocol::ChainTxStatus_TxStatus ChainTxStatus::status() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.status)
  return static_cast< ::protocol::ChainTxStatus_TxStatus >(status_);
}
inline void ChainTxStatus::set_status(::protocol::ChainTxStatus_TxStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.status)
}

// optional string tx_hash = 2;
inline void ChainTxStatus::clear_tx_hash() {
  tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainTxStatus::tx_hash() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.tx_hash)
  return tx_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_tx_hash(const ::std::string& value) {
  
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.tx_hash)
}
inline void ChainTxStatus::set_tx_hash(const char* value) {
  
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainTxStatus.tx_hash)
}
inline void ChainTxStatus::set_tx_hash(const char* value, size_t size) {
  
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainTxStatus.tx_hash)
}
inline ::std::string* ChainTxStatus::mutable_tx_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainTxStatus.tx_hash)
  return tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainTxStatus::release_tx_hash() {
  // @@protoc_insertion_point(field_release:protocol.ChainTxStatus.tx_hash)
  
  return tx_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash != NULL) {
    
  } else {
    
  }
  tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainTxStatus.tx_hash)
}

// optional string source_address = 3;
inline void ChainTxStatus::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainTxStatus::source_address() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.source_address)
  return source_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_source_address(const ::std::string& value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.source_address)
}
inline void ChainTxStatus::set_source_address(const char* value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainTxStatus.source_address)
}
inline void ChainTxStatus::set_source_address(const char* value, size_t size) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainTxStatus.source_address)
}
inline ::std::string* ChainTxStatus::mutable_source_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainTxStatus.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainTxStatus::release_source_address() {
  // @@protoc_insertion_point(field_release:protocol.ChainTxStatus.source_address)
  
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    
  } else {
    
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainTxStatus.source_address)
}

// optional int64 source_account_seq = 4;
inline void ChainTxStatus::clear_source_account_seq() {
  source_account_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainTxStatus::source_account_seq() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.source_account_seq)
  return source_account_seq_;
}
inline void ChainTxStatus::set_source_account_seq(::google::protobuf::int64 value) {
  
  source_account_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.source_account_seq)
}

// optional int64 ledger_seq = 5;
inline void ChainTxStatus::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainTxStatus::ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.ledger_seq)
  return ledger_seq_;
}
inline void ChainTxStatus::set_ledger_seq(::google::protobuf::int64 value) {
  
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.ledger_seq)
}

// optional int64 new_account_seq = 6;
inline void ChainTxStatus::clear_new_account_seq() {
  new_account_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainTxStatus::new_account_seq() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.new_account_seq)
  return new_account_seq_;
}
inline void ChainTxStatus::set_new_account_seq(::google::protobuf::int64 value) {
  
  new_account_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.new_account_seq)
}

// optional .protocol.ERRORCODE error_code = 7;
inline void ChainTxStatus::clear_error_code() {
  error_code_ = 0;
}
inline ::protocol::ERRORCODE ChainTxStatus::error_code() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.error_code)
  return static_cast< ::protocol::ERRORCODE >(error_code_);
}
inline void ChainTxStatus::set_error_code(::protocol::ERRORCODE value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.error_code)
}

// optional string error_desc = 8;
inline void ChainTxStatus::clear_error_desc() {
  error_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainTxStatus::error_desc() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.error_desc)
  return error_desc_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_error_desc(const ::std::string& value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.error_desc)
}
inline void ChainTxStatus::set_error_desc(const char* value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainTxStatus.error_desc)
}
inline void ChainTxStatus::set_error_desc(const char* value, size_t size) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainTxStatus.error_desc)
}
inline ::std::string* ChainTxStatus::mutable_error_desc() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainTxStatus.error_desc)
  return error_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainTxStatus::release_error_desc() {
  // @@protoc_insertion_point(field_release:protocol.ChainTxStatus.error_desc)
  
  return error_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc != NULL) {
    
  } else {
    
  }
  error_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_desc);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainTxStatus.error_desc)
}

// optional int64 timestamp = 9;
inline void ChainTxStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainTxStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.timestamp)
  return timestamp_;
}
inline void ChainTxStatus::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.timestamp)
}

// -------------------------------------------------------------------

// ChainInfoMessage

// optional int64 seq = 1;
inline void ChainInfoMessage::clear_seq() {
  seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainInfoMessage::seq() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInfoMessage.seq)
  return seq_;
}
inline void ChainInfoMessage::set_seq(::google::protobuf::int64 value) {
  
  seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainInfoMessage.seq)
}

// optional string address = 2;
inline void ChainInfoMessage::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInfoMessage::address() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInfoMessage.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfoMessage::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainInfoMessage.address)
}
inline void ChainInfoMessage::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainInfoMessage.address)
}
inline void ChainInfoMessage::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainInfoMessage.address)
}
inline ::std::string* ChainInfoMessage::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainInfoMessage.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInfoMessage::release_address() {
  // @@protoc_insertion_point(field_release:protocol.ChainInfoMessage.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfoMessage::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainInfoMessage.address)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Ledgers_SyncCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Ledgers_SyncCode>() {
  return ::protocol::Ledgers_SyncCode_descriptor();
}
template <> struct is_proto_enum< ::protocol::ChainTxStatus_TxStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ChainTxStatus_TxStatus>() {
  return ::protocol::ChainTxStatus_TxStatus_descriptor();
}
template <> struct is_proto_enum< ::protocol::OVERLAY_MESSAGE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::OVERLAY_MESSAGE_TYPE>() {
  return ::protocol::OVERLAY_MESSAGE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::protocol::ChainMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ChainMessageType>() {
  return ::protocol::ChainMessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_overlay_2eproto__INCLUDED
